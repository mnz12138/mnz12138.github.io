<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marks</title>
  
  <subtitle>iOS开发者，喜欢研究技术。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-05-27T12:03:05.639Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marks - 上海</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解KVO和KVC</title>
    <link href="http://yoursite.com/2018/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO%E5%92%8CKVC/"/>
    <id>http://yoursite.com/2018/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO%E5%92%8CKVC/</id>
    <published>2018-04-03T19:22:44.000Z</published>
    <updated>2023-05-27T12:03:05.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO，即key-value-observing,利用一个key来找到某个属性并监听其值得改变。其实这也是一种典型的观察者模式。<br>简单的说，kvo的用法非常简单。</p><ol><li>添加观察者</li><li>在观察者中实现监听方法，observeValueForKeyPath: ofObject: change: context:（通过查阅文档可以知道，绝大多数对象都有这个方法，因为这个方法属于NSObject）</li><li>移除观察者</li></ol><p><strong>如果将一个对象设定成属性,这个属性是自动支持KVO的,如果这个对象是一个实例变量,那么,这个KVO是需要我们自己来实现的.</strong></p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Student.h</span><br><span class="line">//  Test</span><br><span class="line">//</span><br><span class="line">//  Created by Apple on 2018/4/4.</span><br><span class="line">//  Copyright © 2018年 王全金. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Student : NSObject &#123;</span><br><span class="line">    NSString *_country;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setCountry:(NSString *)country;</span><br><span class="line">- (NSString *)country;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Student.m</span><br><span class="line">//  Test</span><br><span class="line">//</span><br><span class="line">//  Created by Apple on 2018/4/4.</span><br><span class="line">//  Copyright © 2018年 王全金. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">- (void)setCountry:(NSString *)country &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;country&quot;];</span><br><span class="line">    _country = country;</span><br><span class="line">    [self didChangeValueForKey:@&quot;country&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)country &#123;</span><br><span class="line">    return _country;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//手动实现getter和setter</span><br><span class="line">@synthesize name = _name;</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    // 如果监测到键值为country,则指定为非自动监听对象</span><br><span class="line">    if ([key isEqualToString:@&quot;country&quot;]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  Test</span><br><span class="line">//</span><br><span class="line">//  Created by Apple on 2018/3/28.</span><br><span class="line">//  Copyright © 2018年 王全金. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController () </span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Student *student;s</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RootViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    // 创建学生对象</span><br><span class="line">    _student = [Student new];</span><br><span class="line">    </span><br><span class="line">    // 监听属性name</span><br><span class="line">    [_student addObserver:self</span><br><span class="line">               forKeyPath:@&quot;name&quot;  // 属性</span><br><span class="line">                  options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">                  context:nil];</span><br><span class="line">    </span><br><span class="line">    // 监听实例变量age</span><br><span class="line">    [_student addObserver:self</span><br><span class="line">               forKeyPath:@&quot;country&quot;   // 实例变量</span><br><span class="line">                  options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">                  context:nil];</span><br><span class="line">    </span><br><span class="line">    _student.name = @&quot;Marks&quot;; // 改变名字</span><br><span class="line">    _student.country = @&quot;中国&quot;;      // 改变国家</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self removeObserver:_student forKeyPath:@&quot;name&quot;];</span><br><span class="line">    [self removeObserver:_student forKeyPath:@&quot;country&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="KVO的底层实现"><a href="#KVO的底层实现" class="headerlink" title="KVO的底层实现"></a>KVO的底层实现</h4><p>当一个类的属性被观察的时候，系统会通过runtime动态的创建一个该类的派生类，并且会在这个类中重写基类被观察的属性的setter方法，而且系统将这个类的isa指针指向了派生类，从而实现了给监听的属性赋值时调用的是派生类的setter方法。重写的setter方法会在调用原setter方法前后，通知观察对象值得改变。</p><p><img src="/2018/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3KVO%E5%92%8CKVC/877100-146caa2385fe8d2a.png" alt="图片"></p><blockquote><p>facebook开源的工具，KVOController ，是一个简单安全的 KVO（Key-value Observing，键-值 观察）工具，好像挺好用的。</p></blockquote><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><h4 id="KVC概述"><a href="#KVC概述" class="headerlink" title="KVC概述"></a>KVC概述</h4><p>KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。而不是通过调用Setter、Getter方法访问。<br>关键方法定义在 NSKeyValueCodingProtocol<br>KVC支持类对象和内建基本数据类型。</p><h4 id="KVC使用"><a href="#KVC使用" class="headerlink" title="KVC使用"></a>KVC使用</h4><ul><li><p>获取值<br>  valueForKey: 传入NSString属性的名字。<br>  valueForKeyPath: 属性的路径，xx.xx<br>  valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理</p></li><li><p>修改值<br>  setValue:forKey:<br>  setValue:forKeyPath:<br>  setValue:forUnderfinedKey:<br>  setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。</p></li></ul><h4 id="KVC键值查找"><a href="#KVC键值查找" class="headerlink" title="KVC键值查找"></a>KVC键值查找</h4><p>搜索单值成员</p><ul><li><p>setValue:forKey:搜索方式  </p><ol><li>首先搜索setKey:方法。（key指成员变量名，首字母大写）  </li><li>上面的setter方法没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。（NSKeyValueCodingCatogery中实现的类方法，默认实现为返回YES）  </li><li>如果没有找到成员变量，调用setValue:forUnderfinedKey:</li></ol></li><li><p>valueForKey:的搜索方式  </p><ol><li>首先按getKey，key，isKey的顺序查找getter方法，找到直接调用。如果是BOOL、int等内建值类型，会做NSNumber的转换。  </li><li>上面的getter没找到，查找countOfKey、objectInKeyAtindex、KeyAtindexes格式的方法。如果countOfKey和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。  </li><li>还没找到，查找countOfKey、enumeratorOfKey、memberOfKey格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。  </li><li>还是没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。  </li><li>再没找到，调用valueForUndefinedKey。</li></ol></li></ul><h4 id="KVC实现分析"><a href="#KVC实现分析" class="headerlink" title="KVC实现分析"></a>KVC实现分析</h4><p>KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。KVC通过isa-swizzing实现其内部查找定位。isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。</p><p>比如说如下的一行KVC代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[site setValue:@&quot;sitename&quot; forKey:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">//会被编译器处理成</span><br><span class="line">SEL sel = sel_get_uid(setValue:forKey);</span><br><span class="line">IMP method = objc_msg_loopup(site-&gt;isa,sel);</span><br><span class="line">method(site,sel,@&quot;sitename&quot;,@&quot;name&quot;);</span><br></pre></td></tr></table></figure><p>每个类都有一张方法表，是一个hash表，值是还书指针IMP，SEL的名称就是查表时所用的键。<br>SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。<br>IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。</p><h4 id="KVC的内部机制："><a href="#KVC的内部机制：" class="headerlink" title="KVC的内部机制："></a>KVC的内部机制：</h4><p>一个对象在调用setValue的时候进行了如下操作：</p><ul><li>根据方法名找到运行方法的时候需要的环境参数</li><li>他会从自己的isa指针结合环境参数，找到具体的方法实现接口。</li><li>再直接查找得来的具体的实现方法</li></ul><h4 id="KVC支持的聚合运算"><a href="#KVC支持的聚合运算" class="headerlink" title="KVC支持的聚合运算"></a>KVC支持的聚合运算</h4><ul><li>sum 求和</li><li>max 最大值</li><li>min 最小值</li><li>avg 平均值</li><li>count 数量</li></ul><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>新建一个类<code>Person</code>，里面存放一个属性<code>age</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">/** 年龄 */</span><br><span class="line">@property (nonatomic, assign) NSUInteger age;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>创建一个数组，存放<code>Person</code>对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray&lt;Person *&gt; *persons = [NSMutableArray array];</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    p.age = i;</span><br><span class="line">    [persons addObject:p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@sum</code> <code>@min</code> <code>@max</code> <code>@avg</code> <code>@count</code>进行聚合运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSInteger sum = [[persons valueForKeyPath:@&quot;@sum.age&quot;] integerValue];</span><br><span class="line">NSInteger min = [[persons valueForKeyPath:@&quot;@min.age&quot;] integerValue];</span><br><span class="line">NSInteger max = [[persons valueForKeyPath:@&quot;@max.age&quot;] integerValue];</span><br><span class="line">float avg = [[persons valueForKeyPath:@&quot;@avg.age&quot;] floatValue];</span><br><span class="line">NSInteger count = [[persons valueForKeyPath:@&quot;@count.age&quot;] integerValue];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;sum=%zd&quot;, sum);</span><br><span class="line">NSLog(@&quot;min=%zd&quot;, min);</span><br><span class="line">NSLog(@&quot;max=%zd&quot;, max);</span><br><span class="line">NSLog(@&quot;avg=%g&quot;, avg);</span><br><span class="line">NSLog(@&quot;count=%zd&quot;, count);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-04-04 13:42:50.099122+0800 Test[11815:158919] sum=15</span><br><span class="line">2018-04-04 13:42:50.099353+0800 Test[11815:158919] min=1</span><br><span class="line">2018-04-04 13:42:50.099506+0800 Test[11815:158919] max=5</span><br><span class="line">2018-04-04 13:42:50.099631+0800 Test[11815:158919] avg=3</span><br><span class="line">2018-04-04 13:42:50.099867+0800 Test[11815:158919] count=5</span><br></pre></td></tr></table></figure><h5 id="数组中直接存放数值的情况"><a href="#数组中直接存放数值的情况" class="headerlink" title="数组中直接存放数值的情况"></a>数组中直接存放数值的情况</h5><p>直接使用<code>@运算符.floatValue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSNumber *&gt; *arr = @[@1, @2, @3, @4];</span><br><span class="line">NSNumber *avg = [arr valueForKeyPath:@&quot;@avg.floatValue&quot;];</span><br><span class="line">NSNumber *sum = [arr valueForKeyPath:@&quot;@sum.integerValue&quot;];</span><br><span class="line">NSLog(@&quot;avg=%@&quot;, avg);</span><br><span class="line">NSLog(@&quot;sum=%@&quot;, sum);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-04-04 13:47:56.108888+0800 Test[12017:162610] avg=2.5</span><br><span class="line">2018-04-04 13:47:56.109200+0800 Test[12017:162610] sum=10</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;p&gt;KVO，即key-value-observing,利用一个key来找到某个属性并监听其值得改变。其实这也是一种典型的观察者模式。&lt;br&gt;简单的说，kvo的用法非常简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加观察者&lt;/li&gt;
&lt;li&gt;在观察者中实现监听方法，observeValueForKeyPath: ofObject: change: context:（通过查阅文档可以知道，绝大多数对象都有这个方法，因为这个方法属于NSObject）&lt;/li&gt;
&lt;li&gt;移除观察者&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如果将一个对象设定成属性,这个属性是自动支持KVO的,如果这个对象是一个实例变量,那么,这个KVO是需要我们自己来实现的.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Swift可选值</title>
    <link href="http://yoursite.com/2018/04/02/Swift%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    <id>http://yoursite.com/2018/04/02/Swift%E5%8F%AF%E9%80%89%E5%80%BC/</id>
    <published>2018-04-01T23:07:13.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>可选型<code>optional</code> ，表示一个值可能为空。但是这个空，在swift中就叫可选型，用关键字<code>nil</code>表示。它既不是0，也不是不存在，它就是<code>nil</code></p><p>要么是它自身的值，要么为<code>nil</code>。<code>nil</code>就是可选型的默认值</p><span id="more"></span><h3 id="声明一个可选项"><a href="#声明一个可选项" class="headerlink" title="声明一个可选项"></a>声明一个可选项</h3><p>用： 字符类型+? 必须显示的申明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var errorCode:Int? = 404</span><br><span class="line">var errorMessage:String? = &quot;Not Found!&quot;</span><br><span class="line"></span><br><span class="line">errorCode = nil</span><br><span class="line"></span><br><span class="line">print( errorMessage )  // 输出：Optional(&quot;Not Found!&quot;)</span><br></pre></td></tr></table></figure><h3 id="不能隐示的声明"><a href="#不能隐示的声明" class="headerlink" title="不能隐示的声明"></a>不能隐示的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//var errorCode1? = 404 //报错，必须声明类型</span><br><span class="line"></span><br><span class="line">var errorCode2:Int? = 404 //得像这样，显示的申明一个类型</span><br><span class="line"></span><br><span class="line">// Int? 和 Int 不是一种类型</span><br><span class="line">let imInt = 405 //Int 型</span><br><span class="line">errorCode = imInt</span><br><span class="line">print(errorCode)  //Optional(405)</span><br><span class="line"></span><br><span class="line">//imInt = errorCode //报错了，把一个可选型赋值给一个Int型，报错。</span><br></pre></td></tr></table></figure><h3 id="可选型的解包。"><a href="#可选型的解包。" class="headerlink" title="可选型的解包。"></a>可选型的解包。</h3><p>解包就是我得使用它了。确认强制解包用：!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var errorCode3:String? = &quot;404&quot;</span><br><span class="line"></span><br><span class="line">//&quot;the errorcode is &quot; + errorCode3 // 报错:2种不同的类型不能直接拼装使用。</span><br><span class="line"></span><br><span class="line">//如果需要使用，就得解包。用强制解包：！</span><br><span class="line">&quot;the errorcode is &quot; + errorCode3! // 打印：the errorcode is 404</span><br><span class="line"></span><br><span class="line">//用强制解包，是很危险的，如果这个值真的为 nil。然后强制解包，就会报错。</span><br><span class="line"></span><br><span class="line">var errorCode4:String? = nil</span><br><span class="line">//&quot;the errorcode is &quot; + errorCode4! // 报错了：nil被强制解包报错。</span><br></pre></td></tr></table></figure><h3 id="可以用if-判断可选型是否为nil，安全后再用-解包"><a href="#可以用if-判断可选型是否为nil，安全后再用-解包" class="headerlink" title="可以用if 判断可选型是否为nil，安全后再用!解包"></a>可以用if 判断可选型是否为nil，安全后再用!解包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var errorCode5:String? = &quot;502&quot;</span><br><span class="line">if errorCode5 != nil &#123;</span><br><span class="line">    print(errorCode5!) //打印：502</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;No error!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-联合使用-let-关键字解包，可以不用-了"><a href="#if-联合使用-let-关键字解包，可以不用-了" class="headerlink" title="if 联合使用 let 关键字解包，可以不用!了"></a>if 联合使用 let 关键字解包，可以不用!了</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if let unwrappedErrorCode = errorCode5&#123;</span><br><span class="line">    print(unwrappedErrorCode) //打印：502</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;No error!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//也可以用相同的名字：</span><br><span class="line">if let errorCode5 = errorCode5&#123;</span><br><span class="line">    print(errorCode5) //打印：502</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    print(&quot;No error!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-if-let-解包多个可选型的值。相当于-and-操作"><a href="#使用-if-let-解包多个可选型的值。相当于-and-操作" class="headerlink" title="使用 if let 解包多个可选型的值。相当于 and 操作"></a>使用 if let 解包多个可选型的值。相当于 and 操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let errorCode5 = errorCode5, errorMessage = errorMessage&#123;</span><br><span class="line">    print(&quot;code is \(errorCode5), msg is \(errorMessage)&quot;)</span><br><span class="line">    //打印：code is 502, msg is Not Found!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-if-let-再加-where-进一步限定"><a href="#使用-if-let-再加-where-进一步限定" class="headerlink" title="使用 if let 再加 where 进一步限定"></a>使用 if let 再加 where 进一步限定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let errorCode5 = errorCode5, errorMessage = errorMessage where errorCode5 == &quot;502&quot;&#123;</span><br><span class="line">    print(&quot;code is \(errorCode5), msg is \(errorMessage)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(errorCode5) // 它自身的值并没有被改变：Optional(&quot;502&quot;)</span><br></pre></td></tr></table></figure><h3 id="使用-guard-let，可以不用-了"><a href="#使用-guard-let，可以不用-了" class="headerlink" title="使用 guard let，可以不用!了"></a>使用 guard let，可以不用!了</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let str: String? = &quot;&quot;</span><br><span class="line">guard let newStr = str else &#123;</span><br><span class="line">    print(&quot;str为nil&quot;)</span><br><span class="line">    //str为nil时，在这里会直接return</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">//下面使用newStr不用解包，newStr为非可选类型</span><br><span class="line">print(newStr)</span><br></pre></td></tr></table></figure><h3 id="使用-guard-let-解包多个可选型的值。相当于-and-操作"><a href="#使用-guard-let-解包多个可选型的值。相当于-and-操作" class="headerlink" title="使用 guard let 解包多个可选型的值。相当于 and 操作"></a>使用 guard let 解包多个可选型的值。相当于 and 操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let str1: String? = &quot;&quot;</span><br><span class="line">let str2: String? = &quot;&quot;</span><br><span class="line">guard let newStr1 = str1, let newStr2 = str2 else &#123;</span><br><span class="line">    print(&quot;str1或str2为nil&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">print(newStr1)</span><br><span class="line">print(newStr2)</span><br></pre></td></tr></table></figure><h3 id="Optional-chaining-链式操作"><a href="#Optional-chaining-链式操作" class="headerlink" title="Optional chaining 链式操作"></a>Optional chaining 链式操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//解包</span><br><span class="line">var errorMessage2: String? = &quot;Not Found&quot;</span><br><span class="line">if let errorMessage2 = errorMessage2&#123;</span><br><span class="line">    print(errorMessage2.uppercaseString) // &quot;NOT FOUND&quot; 全部大写了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//chaining操作就是可以直接用：</span><br><span class="line"></span><br><span class="line">if let errorMessage2 = errorMessage2?.uppercaseString&#123;</span><br><span class="line">    print(errorMessage2) // &quot;NOT FOUND&quot; 全部大写了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//也可以直接用 ！强制解包，前提是你确定一定不为nil。</span><br><span class="line">let upperMessage2 = errorMessage2!.uppercaseString //&quot;NOT FOUND&quot; 全部大写了</span><br></pre></td></tr></table></figure><h3 id="使用-解包。更加单的三目运算符"><a href="#使用-解包。更加单的三目运算符" class="headerlink" title="使用 ?? 解包。更加单的三目运算符"></a>使用 ?? 解包。更加单的三目运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let message2 = errorMessage == nil ? &quot;No error&quot; : errorMessage!</span><br><span class="line"></span><br><span class="line">//等价。如果 errorMessage 解包成功，就把解包的值给 message3</span><br><span class="line">//如果 errorMessage 解包失败，message3的值为 &quot;No error&quot;</span><br><span class="line">let message3 = errorMessage ?? &quot;No error&quot; // &quot;Not Found!&quot;</span><br></pre></td></tr></table></figure><h3 id="在元祖里面使用可选型"><a href="#在元祖里面使用可选型" class="headerlink" title="在元祖里面使用可选型"></a>在元祖里面使用可选型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//errorMessage 设置为可选</span><br><span class="line">var error1:(errorCode:Int, errorMsg:String?) = (404, &quot;Not found!&quot;)</span><br><span class="line"></span><br><span class="line">error1.errorMsg = nil //成功</span><br><span class="line"></span><br><span class="line">print(error1) //打印：(404, nil)</span><br><span class="line"></span><br><span class="line">//把整个元祖设置为可选</span><br><span class="line">var error2:(errorCode:Int, errorMsg:String)? = (404, &quot;Not Found!&quot;)</span><br><span class="line"></span><br><span class="line">error2 = nil //成功的</span><br><span class="line"></span><br><span class="line">print(error2) // 打印：nil</span><br></pre></td></tr></table></figure><p><a href="http://makaidong.com/think2me/1/305761_12435222.html">摘自</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可选型&lt;code&gt;optional&lt;/code&gt; ，表示一个值可能为空。但是这个空，在swift中就叫可选型，用关键字&lt;code&gt;nil&lt;/code&gt;表示。它既不是0，也不是不存在，它就是&lt;code&gt;nil&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要么是它自身的值，要么为&lt;code&gt;nil&lt;/code&gt;。&lt;code&gt;nil&lt;/code&gt;就是可选型的默认值&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中enum、struct、class</title>
    <link href="http://yoursite.com/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/"/>
    <id>http://yoursite.com/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/</id>
    <published>2018-04-01T05:01:17.000Z</published>
    <updated>2023-05-28T10:03:28.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Swift type System</strong></p><p><img src="/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/13630782e345f512c635c19.png" alt="图片"></p><p>Swift是强类型的，尽管只有六种类型。</p><ul><li>命名类型： protocol, class , struct , enum</li><li>复合类型：tuple, function</li></ul><blockquote><p>可能会有疑问，那些基本类型：Bool，Int，UInt, Float, Double, Character, String, Array, Set, Dictionary, Optional。实际上他们都是通过命名类型创建的。</p></blockquote><h3 id="Struct-Class-and-Enum-对比"><a href="#Struct-Class-and-Enum-对比" class="headerlink" title="Struct Class and Enum 对比"></a>Struct Class and Enum 对比</h3><table><thead><tr><th align="center"></th><th align="center">copy by</th><th align="center">inheritance</th><th align="center">static variable</th><th align="center">instance variable</th><th align="center">static method</th><th align="center">instance method</th></tr></thead><tbody><tr><td align="center">Class</td><td align="center">Reference</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">Struct</td><td align="center">Value</td><td align="center">✘</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">Enum</td><td align="center">Value</td><td align="center">✘</td><td align="center">✅</td><td align="center">✘</td><td align="center">✅</td><td align="center">✅</td></tr></tbody></table><h4 id="枚举、结构体、类的共同点："><a href="#枚举、结构体、类的共同点：" class="headerlink" title="枚举、结构体、类的共同点："></a>枚举、结构体、类的共同点：</h4><ul><li>定义属性和方法；</li><li>下标语法访问值；</li><li>初始化器；</li><li>支持扩展增加功能；</li><li>可以遵循协议；</li><li>都可以使用泛型；</li></ul><h4 id="类特有的功能："><a href="#类特有的功能：" class="headerlink" title="类特有的功能："></a>类特有的功能：</h4><ul><li>继承；</li><li>允许类型转换；</li><li>析构方法释放资源；</li><li>引用计数；</li></ul><span id="more"></span><h3 id="如何抉择？"><a href="#如何抉择？" class="headerlink" title="如何抉择？"></a>如何抉择？</h3><p>通常，在平时的编程中，按照对象的生命周期形态，可以把使用的类型分成两大类：</p><ul><li><strong>一类必须有明确生命周期的，它们必须被明确的初始化、使用、最后明确的被释放。</strong>例如：文件句柄、数据库连接、线程同步锁等等。这些类型的初始化和释放都不是拷贝内存这么简单，通常，这类内容，我们会选择使用<code>class</code>来实现。</li><li><strong>另一类，则是没有那么明显的生命周期。</strong>例如：整数、字符串、URL等等。这些对象一旦被创建之后，就很少被修改，我们只是需要使用这些对象的值，用完之后，我们也无需为这些对象的销毁做更多额外的工作，只是把它们占用的内存回收就好了。这类内容，通常我们会选择使用<code>struct</code>或<code>enum</code>来实现。</li></ul><h4 id="什么时候该用值类型："><a href="#什么时候该用值类型：" class="headerlink" title="什么时候该用值类型："></a>什么时候该用值类型：</h4><ul><li>要用==运算符来比较实例的数据时</li><li>你希望那个实例的拷贝能保持独立的状态时</li><li>数据会被多个线程使用时</li></ul><h4 id="什么时候该用引用类型（class）："><a href="#什么时候该用引用类型（class）：" class="headerlink" title="什么时候该用引用类型（class）："></a>什么时候该用引用类型（class）：</h4><ul><li>要用==运算符来比较实例身份的时候</li><li>你希望有创建一个共享的、可变对象的时候</li></ul><h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><h4 id="Struct的定义和初始化"><a href="#Struct的定义和初始化" class="headerlink" title="Struct的定义和初始化"></a>Struct的定义和初始化</h4><p><strong>定义结构体</strong><br>下面定义了一个二维空间坐标的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Double</span><br><span class="line">    var y: Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构体包含两个名x和y的存储属性。存储属性是被绑定和存储在结构体中的常量或变量。</p><p><strong>初始化</strong></p><ul><li>结构体类型的逐一初始化，所有的结构体都有一个自动生成的成员逐一构造器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var pointA = Point(x: 10, y: 20)</span><br></pre></td></tr></table></figure><ul><li>默认初始化，我们也可以在定义的时候直接给属性初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    var y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">var pointB = Point()</span><br></pre></td></tr></table></figure><p>使用这种方法，<strong>必须给每一个属性指定默认值</strong>。因为Swift中要求<code>init</code>方法必须初始化自定义类型每个属性。如果无法做到，我们可以自定义逐一初始化方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x : Double</span><br><span class="line">    var y : Double</span><br><span class="line">    init(_ x : Double = 0.0, y : Double = 0.0) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们自定义<code>init</code>方法之后，Swift将不会再自动创建逐一初始化方法。</p><h4 id="Struct-值类型本质"><a href="#Struct-值类型本质" class="headerlink" title="Struct 值类型本质"></a>Struct 值类型本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var pointB = Point(200, y: 100)</span><br><span class="line">var pointC = Point(100, y: 200) &#123;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;\(pointC)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pointC = pointB</span><br><span class="line">// Point(x: 200.0, y: 100.0)</span><br><span class="line">pointC.x = 200</span><br><span class="line">//Point(x: 200.0, y: 100.0)</span><br></pre></td></tr></table></figure><p>通过<code>didSet</code>观察<code>pointC</code>的变化。当修改<code>pointC</code>变量值时，控制台输出<code>Point(x: 200.0, y: 100.0)</code>, 但是，修改<code>pointC</code>的修改某个属性，也会触发<code>didSet</code>。</p><p>这就是值语义的本质：即使字面上修改了<code>pointC</code>变量的某个属性，但实际执行的逻辑是重新给<code>pointC</code>赋值一个新的<code>Point</code>对象。</p><h4 id="为Struct添加方法"><a href="#为Struct添加方法" class="headerlink" title="为Struct添加方法"></a>为Struct添加方法</h4><p>给<code>struct</code>添加的方法，默认的都是只读的。计算Point之间的距离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Point &#123;</span><br><span class="line">    func distance(to: Point) -&gt; Double &#123;</span><br><span class="line">        let distX = self.x - to.x</span><br><span class="line">        let distY = self.y - to.y</span><br><span class="line">        return sqrt(distX * distX + distY * distY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pointC.distance(to: Point(0, y: 0))</span><br></pre></td></tr></table></figure><p>当我们定义一个移动X轴坐标点的方法时，会导致编译错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Point &#123;</span><br><span class="line">    func move(to: Point) &#123;</span><br><span class="line">        self = to </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提示self is immutable , 必须使用<code>mutating</code>修饰这个方法， Swift编译器就会在所有的<code>mutating</code>方法第一个参数的位置，自动添加一个<code>inout Self</code>参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Point &#123;</span><br><span class="line">    /* self: inout Self */</span><br><span class="line">    mutating func move(to: Point) &#123;</span><br><span class="line">        self = to</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，是关于Struct类型的基本内容。</p><ul><li>init方法的合成规则</li><li>值语义在struct上的表现</li></ul><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>在Swift中，对<code>enum</code>做了诸多改进和增强，它可以有自己的属性，方法，还可以遵从<code>protocol</code>。</p><h4 id="定义enum"><a href="#定义enum" class="headerlink" title="定义enum"></a>定义enum</h4><p>定义了一个<code>colorName</code>枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum ColorName &#123;</span><br><span class="line">    case black</span><br><span class="line">    case silver</span><br><span class="line">    case gray</span><br><span class="line">    case white</span><br><span class="line">    case red</span><br><span class="line">    //.... and so on ....</span><br><span class="line">&#125;</span><br><span class="line">// 也可以写在同一行上，用逗号隔开：</span><br><span class="line">enum Month &#123;</span><br><span class="line">    case january, februray, march,</span><br><span class="line">    april, may, june, july,</span><br><span class="line">    august, september, october,</span><br><span class="line">    november, december</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let black = ColorName.black</span><br><span class="line">let jan = Month.january</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>与C和Objective-C不同，Swift的枚举成员在被创建时不会被赋予一个默认的整数值。上面定义的枚举成员是完备的值，这些值的类型就是定义好的枚举ColorName或Month。</p></blockquote><h4 id="理解Enum的“Value”"><a href="#理解Enum的“Value”" class="headerlink" title="理解Enum的“Value”"></a>理解Enum的“Value”</h4><h5 id="case-本身就是值"><a href="#case-本身就是值" class="headerlink" title="case 本身就是值"></a>case 本身就是值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func myColor(color: ColorName) -&gt; String &#123;</span><br><span class="line">    switch color &#123;</span><br><span class="line">    case .black:</span><br><span class="line">        return &quot;black&quot;</span><br><span class="line">    case .red:</span><br><span class="line">        return &quot;red&quot;</span><br><span class="line">    default :</span><br><span class="line">        return &quot;other&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><ul><li>color的类型可以通过type inference推导出是ColorName。因此，可以省略enum的名字。</li><li>当Switch…case…将color的所有的值都列举出来时，可以省略default。</li></ul><h5 id="绑定值-raw-values"><a href="#绑定值-raw-values" class="headerlink" title="绑定值(raw values)"></a>绑定值(raw values)</h5><p>在Swift中，<code>enum</code>默认不会为<code>case</code>绑定一个整数值。但是我们可以手动的绑定值，这个“绑定”来的值，叫做raw values。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction : Int &#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在定义Direction，Swift就会依次把<code>case</code>绑定上值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let east = Direction.east.rawValue // 0</span><br></pre></td></tr></table></figure><h5 id="关联值（Associated-value"><a href="#关联值（Associated-value" class="headerlink" title="关联值（Associated value)"></a>关联值（Associated value)</h5><p>在Swift中， 我们可以给每一个<code>case</code>绑定不同类型的值，我们管这种值叫做<code>Associated value</code>。</p><p>定义了一个表示CSSColor的<code>enum</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum CSSColor &#123;</span><br><span class="line">    case named(ColorName)</span><br><span class="line">    case rgb(UInt8, UInt8, UInt8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var color1 = CSSColor.named(.black)</span><br><span class="line">var color2 = CSSColor.rgb(0xAA, 0xAA, 0xAA)</span><br><span class="line">switch color2 &#123;</span><br><span class="line">case  let  .named(color):</span><br><span class="line">     print(&quot;\(color)&quot;)</span><br><span class="line">case .rgb(let r, let g, let b):</span><br><span class="line">    print(&quot;\(r), \(g), \(b)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>提取”关联值“的内容时，可以把<code>let</code>和<code>var</code>写在<code>case</code>前面或者后面。例如：<code>named</code>和<code>rgb</code>。</p></blockquote><h4 id="协议和方法（Protocol-and-Method）"><a href="#协议和方法（Protocol-and-Method）" class="headerlink" title="协议和方法（Protocol and Method）"></a>协议和方法（Protocol and Method）</h4><p>在Swift中，<code>enum</code>和其他的命名类型一样，也可以采用<code>protocol</code>。</p><p>例如： 给CSSColor添加一个文本表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension CSSColor: CustomStringConvertible &#123;</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .named(let colorname):</span><br><span class="line">            return colorname.rawValue</span><br><span class="line">        case .rgb(let red, let green, let blue):</span><br><span class="line">            return String(format: &quot;#%02X%02X%02X&quot;, red, green, blue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let color3 = CSSColor.named(.red)</span><br><span class="line">let color4 = CSSColor.rgb(0xBB, 0xBB, 0xBB)</span><br><span class="line">print(&quot;color3=\(color3), color4=\(color4)&quot;) </span><br><span class="line">//color3=red, color4=#BBBBBB</span><br></pre></td></tr></table></figure><h4 id="什么是Copy-on-write-COW-？"><a href="#什么是Copy-on-write-COW-？" class="headerlink" title="什么是Copy on write (COW) ？"></a>什么是Copy on write (COW) ？</h4><p>COW是一种常见的计算机技术，有助于在复制结构时提高性能。例如：一个数组中有1000个元素，如果你复制数组到另一个变量，Swift将复制全部的元素，即使最终两个数组的内容相同。</p><p>这个问题可以使用COW解决：当将两个变量指向同一数组时，他们指向相同的底层数据。两个变量指向相同的数据可能看起来矛盾。解决方法：当修改第二个变量的时候，Swift才会去复制一个副本，第一个不会改变。<br>通过延迟复制操作，直到实际使用到的时候 才去复制，以此确保没有浪费的工作。</p><blockquote><p>注意：COW是特别添加到Swift数组和字典的功能，自定义的数据类型不会自动实现。</p></blockquote><h4 id="值类型和引用类型（Value-vs-Reference-Type）"><a href="#值类型和引用类型（Value-vs-Reference-Type）" class="headerlink" title="值类型和引用类型（Value vs. Reference Type）"></a>值类型和引用类型（Value vs. Reference Type）</h4><p>Class和Struct有很多相似的地方，他们都可以用来自定义类型、都可以有属性、都可以有方法。作为Swift中的引用类型，class表达的是一个具有明生命周期的对象，我们关心的是类的生命周期。而值类型，我关注的是值本身。</p><h5 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h5><ol><li><p>引用类型必须明确指定init方法<br>Swift中class不会自动生成init方法。如果不定义编译器报错。</p></li><li><p>引用类型关注的是对象本身 Circle (定义为Class)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = Circle()</span><br><span class="line">a.radius = 80</span><br><span class="line">var b = a</span><br><span class="line">a.radius = 1000</span><br><span class="line">b.radius // 1000</span><br></pre></td></tr></table></figure><p> Circle(定义为Struct)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = Circle()</span><br><span class="line">a.radius = 80</span><br><span class="line">var b = a</span><br><span class="line">a.radius = 1000</span><br><span class="line">b.radius // 80</span><br></pre></td></tr></table></figure><p> 使用值类型创建新对象时，将复制；使用引用类型时，新变量引用同一个对象。这是两者的关键区别。</p></li><li><p>引用类型的默认值是可以修改的<br>我们之前提到过，给struct添加的方法，默认的都是只读的。如果要修改必须用mutating来修饰。class中则不同，我们可以直接给 self赋值。</p></li></ol><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="理解class类型的各种init方法"><a href="#理解class类型的各种init方法" class="headerlink" title="理解class类型的各种init方法"></a>理解class类型的各种init方法</h4><p>由于<code>class</code>之间可以存在继承关系，因此它的初始化过程要比<code>struct</code>复杂，为了保证一个<code>class</code>中的所有属性都被初始化，Swift中引入一系列特定规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double</span><br><span class="line">    var y : Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这项写是不行了，因为没有定义初始化方法。</p><h5 id="指定构造器-Designated-init"><a href="#指定构造器-Designated-init" class="headerlink" title="指定构造器(Designated init)"></a>指定构造器(Designated init)</h5><p>上面的Point2D有一个默认的初始化方法，有两种办法：第一种给每一个属性都添加默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">&#125;</span><br><span class="line">let origin = Point2D()</span><br></pre></td></tr></table></figure><p>这种方法只能创建一个固定的<code>class</code>。另外一种，添加一个<code>memberwise init</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">    init(x: Double, y: Double) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加个一个<code>memberwise init</code>方法，我们可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let point = Point2D(x: 1, y: 1)</span><br></pre></td></tr></table></figure><p>但是，如果你现在使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let point = Point2D()  // Error</span><br></pre></td></tr></table></figure><p>结果会导致编译错误。 因为，我们接手了<code>init</code>的定义后，编译就不会插手<code>init</code>工作。所以，在定义<code>init</code>方法时添加默认参数， 我们称这种初始化为 <code>designated init</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">    init(x: Double = 0, y: Double = 0) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="便利构造器-（convenience-init）"><a href="#便利构造器-（convenience-init）" class="headerlink" title="便利构造器 （convenience init）"></a>便利构造器 （convenience init）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">    init(x: Double = 0, y: Double = 0) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init(at: (Double, Double) ) &#123;</span><br><span class="line">        self.init(x: at.0, y: at.1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>convenience</code>关键字修改；</li><li>必须调用<code>designated init</code>完成对象的初始化；如果直接调用self.x或self.y，会导致编译错误。</li></ul><h5 id="可失败构造器-（Failable-init）"><a href="#可失败构造器-（Failable-init）" class="headerlink" title="可失败构造器 （Failable init）"></a>可失败构造器 （Failable init）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    // .... </span><br><span class="line">    convenience init?(at: (String, String)) &#123;</span><br><span class="line">        guard let x = Double(at.0),   let y = Double(at.1) else &#123;</span><br><span class="line">          return nil</span><br><span class="line">        &#125;</span><br><span class="line">        self.init(at:(x, y))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>String tuple</code>版的<code>init</code>可能失败，所以需要用<code>init?</code>形式定义。在实现里面，如果<code>String</code>无法转换为成<code>Double</code>， 则返回<code>nil</code>。</p><blockquote><p>注意：<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此，return nil表示构造失败，而不能return表示成功。</p></blockquote><h4 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h4><p>当类之间存在继承关系的时候，为了保证派生类和基类的属性都被初始化，Swift采用以下三条规则限制构造器之间的代理调用：</p><ul><li>指定构造器必须调用其直接父类的指定构造器</li><li>便利构造器必须调用同类中定义的其它构造器</li><li>便利构造器必须最终导致一个指定构造器被调用</li></ul><p>简单说：</p><ul><li>指定构造器必须总是向上代理</li><li>便利构造器必须总是横向代理</li></ul><h5 id="init的继承"><a href="#init的继承" class="headerlink" title="init的继承"></a>init的继承</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point3D: Point2D &#123;</span><br><span class="line">    var z: Double = 0</span><br><span class="line">&#125;</span><br><span class="line">let origin3D = Point3D()</span><br><span class="line">let point31 = Point3D(x: 1, y: 1)</span><br><span class="line">let point33 = Point3D(at: (2, 3)) // 继承基类 convenience init</span><br></pre></td></tr></table></figure><ul><li>如果派生类没有定义任何designated initializer，那么它将自动继承所有基类的designated initializer。</li><li>如果一个派生类定义了所有基类的designated init,那么它将自动继承基类所有的convenience init。</li></ul><h5 id="重载init方法"><a href="#重载init方法" class="headerlink" title="重载init方法"></a>重载init方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point3D: Point2D &#123;</span><br><span class="line">    var z: Double</span><br><span class="line">    init(x: Double = 0, y: Double = 0, z: Double = 0) &#123;</span><br><span class="line">        self.z = z</span><br><span class="line">        super.init(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在派生类自定义<code>designated init</code>, 表示明确控制派生类的初始化构造过程, Swift 就不会干涉构造过程。那么，之前创建<code>Point3D</code>就会出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let point33 = Point3D(at: (2, 3))  // Error </span><br></pre></td></tr></table></figure><p>如果想让<code>Point3D</code>从<code>Point2D</code>继承所有的<code>convenience init</code>，只有在派生类中实现所有的<code>designated init</code>方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Point3D: Point2D &#123;</span><br><span class="line">    var z: Double</span><br><span class="line">    init(x: Double = 0, y: Double = 0, z: Double = 0) &#123;</span><br><span class="line">        self.z = z</span><br><span class="line">        super.init(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">    override init(x: Double, y: Double) &#123;</span><br><span class="line">        // 注意先后顺序</span><br><span class="line">        self.z = 0</span><br><span class="line">        super.init(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，就可以正常工作了。只要派生类拥有基类所有的<code>designated init</code>方法，他就会自动获得所有基类的<code>convenience init</code>方法。另外，重载基类<code>convenience init</code>方法，是不需要<code>override</code>关键字修饰的。</p><h5 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h5><p>Swift为了保证在一个继承关系中，派生类和基类的属性都可以正确初始化而约定的初始化机制。简单来说，这个机制把派生类的初始化过程分成了两个阶段。</p><ul><li>阶段一： 从派生类到基类，自下而上让类的每个属性有初始值</li><li>阶段二：所有属性都有初始值之后，从基类到派生类，自上而下对类的每个属性进行进一步加工。</li></ul><p>两段式构造过程让构造过程更安全，同时整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外赋予不同的值。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://link.jianshu.com/?t=https://developer.apple.com/reference/swift">Swift Standard Library</a><br><a href="https://link.jianshu.com/?t=https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift">Getting to Know Enums, Structs and Classes in Swift - raywenderlich</a></p><p><a href="https://www.jianshu.com/p/a10f554ac63b">摘自</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Swift type System&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/13630782e345f512c635c19.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;Swift是强类型的，尽管只有六种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名类型： protocol, class , struct , enum&lt;/li&gt;
&lt;li&gt;复合类型：tuple, function&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可能会有疑问，那些基本类型：Bool，Int，UInt, Float, Double, Character, String, Array, Set, Dictionary, Optional。实际上他们都是通过命名类型创建的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Struct-Class-and-Enum-对比&quot;&gt;&lt;a href=&quot;#Struct-Class-and-Enum-对比&quot; class=&quot;headerlink&quot; title=&quot;Struct Class and Enum 对比&quot;&gt;&lt;/a&gt;Struct Class and Enum 对比&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;copy by&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;inheritance&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;static variable&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;instance variable&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;static method&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;instance method&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Class&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Reference&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Struct&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Value&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✘&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Enum&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Value&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✘&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✘&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;✅&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&quot;枚举、结构体、类的共同点：&quot;&gt;&lt;a href=&quot;#枚举、结构体、类的共同点：&quot; class=&quot;headerlink&quot; title=&quot;枚举、结构体、类的共同点：&quot;&gt;&lt;/a&gt;枚举、结构体、类的共同点：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义属性和方法；&lt;/li&gt;
&lt;li&gt;下标语法访问值；&lt;/li&gt;
&lt;li&gt;初始化器；&lt;/li&gt;
&lt;li&gt;支持扩展增加功能；&lt;/li&gt;
&lt;li&gt;可以遵循协议；&lt;/li&gt;
&lt;li&gt;都可以使用泛型；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;类特有的功能：&quot;&gt;&lt;a href=&quot;#类特有的功能：&quot; class=&quot;headerlink&quot; title=&quot;类特有的功能：&quot;&gt;&lt;/a&gt;类特有的功能：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;继承；&lt;/li&gt;
&lt;li&gt;允许类型转换；&lt;/li&gt;
&lt;li&gt;析构方法释放资源；&lt;/li&gt;
&lt;li&gt;引用计数；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局语法</title>
    <link href="http://yoursite.com/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2018-03-25T18:36:22.000Z</published>
    <updated>2023-05-27T11:58:43.408Z</updated>
    
    <content type="html"><![CDATA[<p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display">display</a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">position</a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float">float</a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><p>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p><strong>Flex布局将成为未来布局的首选方案。</strong></p><span id="more"></span><h3 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为Flex布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit内核的浏览器，必须加上-webkit前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/3791e575c48b3698be6a94ae1dbff79d.png" alt="图片"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p>以下6个属性设置在容器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">flex-wrap</span><br><span class="line">flex-flow</span><br><span class="line">justify-content</span><br><span class="line">align-items</span><br><span class="line">align-content</span><br></pre></td></tr></table></figure><h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/0cbe5f8268121114e87d0546e53cda6e.png" alt="图片"></p><p>它可能有4个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure><h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/903d5b7df55779c03f2687a7d4d6bcea.png" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可能取三个值。</p><p>（1）nowrap（默认）：不换行。</p><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/9da1f23965756568b4c6ea7124db7b9a.png" alt="图片"></p><p>（2）wrap：换行，第一行在上方。</p><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/3c6b3c8b8fe5e26bca6fb57538cf72d9.jpg" alt="图片"></p><p>（3）wrap-reverse：换行，第一行在下方。</p><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/fb4cf2bab8b6b744b64f6d7a99cd577c.jpg" alt="图片"></p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p>justify-content属性定义了项目在主轴上的对齐方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/c55dfe8e3422458b50e985552ef13ba5.png" alt="图片"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start（默认值）：左对齐</span><br><span class="line">flex-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure><h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p>align-items属性定义项目在交叉轴上如何对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/2b0c39c7e7a80d5a784c8c2ca63cde17.png" alt="图片"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex-start：交叉轴的起点对齐。</span><br><span class="line">flex-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure><h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/f10918ccb8a13247c9d47715a2bd2c33.png" alt="图片"></p><p>该属性可能取6个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flex-start：与交叉轴的起点对齐。</span><br><span class="line">flex-end：与交叉轴的终点对齐。</span><br><span class="line">center：与交叉轴的中点对齐。</span><br><span class="line">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line">stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><p>以下6个属性设置在项目上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order</span><br><span class="line">flex-grow</span><br><span class="line">flex-shrink</span><br><span class="line">flex-basis</span><br><span class="line">flex</span><br><span class="line">align-self</span><br></pre></td></tr></table></figure><h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/59e399c72daafcfcc20ede36bf32f266.png" alt="图片"></p><h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/f41c08bb35962ed79e7686f735d6cd78.png" alt="图片"></p><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/240d3e960043a729bb3ff5e34987904f.jpg" alt="图片"></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/55b19171b8b6b9487d717bf2ecbba6de.png" alt="图片"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;布局的传统解决方案，基于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/box_model&quot;&gt;盒状模型&lt;/a&gt;，依赖 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display&quot;&gt;display&lt;/a&gt;属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/position&quot;&gt;position&lt;/a&gt;属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/float&quot;&gt;float&lt;/a&gt;属性。它对于那些特殊布局非常不方便，比如，&lt;a href=&quot;https://css-tricks.com/centering-css-complete-guide/&quot;&gt;垂直居中&lt;/a&gt;就不容易实现。&lt;/p&gt;
&lt;p&gt;2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flex布局将成为未来布局的首选方案。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Flex" scheme="http://yoursite.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>iOS原生网络请求</title>
    <link href="http://yoursite.com/2018/03/24/iOS%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2018/03/24/iOS%E5%8E%9F%E7%94%9F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</id>
    <published>2018-03-24T05:08:31.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、URL-Session的基本概念"><a href="#一、URL-Session的基本概念" class="headerlink" title="一、URL Session的基本概念"></a>一、URL Session的基本概念</h2><h3 id="1-三种工作模式："><a href="#1-三种工作模式：" class="headerlink" title="1. 三种工作模式："></a>1. 三种工作模式：</h3><ul><li>默认会话模式（default）：工作模式类似于原来的NSURLConnection，使用的是基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。</li><li>瞬时会话模式（ephemeral）：该模式不使用磁盘保存任何数据。所有和会话相关的caches，证书，cookies等都被保存在RAM中，因此当程序使会话无效，这些缓存的数据就会被自动清空。</li><li>后台会话模式（background）：该模式在后台完成上传和下载，在创建Configuration对象的时候需要提供一个NSString类型的ID用于标识完成工作的后台会话。</li></ul><h3 id="2-NSURLSession支持的四种任务"><a href="#2-NSURLSession支持的四种任务" class="headerlink" title="2. NSURLSession支持的四种任务"></a>2. NSURLSession支持的四种任务</h3><p>NSURLSession类支持四种类型的任务：加载数据，下载和上传，建立一个TCP/IP连接。</p><h2 id="二、相关的类"><a href="#二、相关的类" class="headerlink" title="二、相关的类"></a>二、相关的类</h2><h3 id="1-NSURLConnection和NSURLSession"><a href="#1-NSURLConnection和NSURLSession" class="headerlink" title="1. NSURLConnection和NSURLSession"></a>1. NSURLConnection和NSURLSession</h3><p>NSURLConnection这个名字，实际上指的是一组构成Foundation框架中URL加载系统的相互关联的组件：NSURLRequest，NSURLResponse，NSURLProtocol，NSURLCache，NSHTTPCookieStorage，NSURLCredentialStorage，以及和它同名的NSURLConnection。<br>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。<br>NSURLSession也是一组相互依赖的类，它的大部分组件和NSURLConnection中的组件相同如NSURLRequest，NSURLCache等。而NSURLSession的不同之处在于，它将NSURLConnection替换为NSURLSession和NSURLSessionConfiguration，以及4个NSURLSessionTask的子类：NSURLSessionDataTask, NSURLSessionUploadTask, NSURLSessionDownloadTask，NSURLSessionStreamTask。</p><p><strong>iOS为了适应不同的应用场景提供了不同类型的NSURLSessionTask</strong></p><ul><li>NSURLSessionTask : Task的抽象基类</li><li>NSURLSessionDataTask  //一般的get、post等请求</li><li>NSURLSessionUploadTask // 用于上传文件或者数据量比较大的请求</li><li>NSURLSessionDownloadTask //用于下载文件或者数据量比较大的请求</li><li>NSURLSessionStreamTask //建立一个TCP/IP连接的主机名和端口或一个网络服务对象。可以执行一个异步的读写</li></ul><h3 id="2-NSURLSessionConfiguration"><a href="#2-NSURLSessionConfiguration" class="headerlink" title="2. NSURLSessionConfiguration"></a>2. NSURLSessionConfiguration</h3><p>NSURLConnection是全局性的，即它的配置对全局有效，如果有两个链接需要不同的cookies、证书这些公共资源，则NSURLConnection无法满足要求，这时NSURLSession的优势则体现出来，NSURLSession可以同过NSURLSessionConfiguration可以设置全局的网络访问属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">// delegateQueue：请求完成回调函数和代理函数的运行线程，如果为nil则系统自动创建一个串行队列，不影响sessionTask的运行线程</span><br><span class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br></pre></td></tr></table></figure><h4 id="三种会话方式："><a href="#三种会话方式：" class="headerlink" title="三种会话方式："></a>三种会话方式：</h4><ol><li>defaultSessionConfiguration：进程内会话（默认会话），类似 NSURLConnection的标准配置，用硬盘来缓存数据。</li><li>ephemeralSessionConfiguration：临时的进程内会话（内存），不会将cookie、缓存储存到本地，只会放到内存中，当应用程序退出后数据也会消失,可以用于实现“秘密浏览”。</li><li>backgroundSessionConfiguration：建立后台会话可以在应用程序挂起，退出，崩溃的情况下运行上传和下载任务，后台另起一个线程。另外，系统会根据设备的负载程度决定分配下载的资源，因此有可能会很慢甚至超时失败。</li></ol><h4 id="设置一些网络属性"><a href="#设置一些网络属性" class="headerlink" title="设置一些网络属性:"></a>设置一些网络属性:</h4><ul><li>HTTPAdditionalHeaders：可以设置出站请求的数据头</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configuration.HTTPAdditionalHeaders = @&#123; </span><br><span class="line">    @&quot;Accept&quot;: @&quot;application/json&quot;,</span><br><span class="line">    @&quot;Accept-Language&quot;: @&quot;en&quot;,</span><br><span class="line">    @&quot;Authorization&quot;: authString, </span><br><span class="line">    @&quot;User-Agent&quot;: userAgentString</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>networkServiceType，设置网络服务类型<ul><li>NSURLNetworkServiceTypeDefault 默认</li><li>NSURLNetworkServiceTypeVoIP VoIP</li><li>NSURLNetworkServiceTypeVideo 视频</li><li>NSURLNetworkServiceTypeBackground 后台</li><li>NSURLNetworkServiceTypeVoice 语音</li><li>NSURLNetworkServiceTypeCallSignaling 电话</li></ul></li><li>allowsCellularAccess：允许蜂窝访问</li><li>timeoutIntervalForRequest：请求的超时时长</li><li>timeoutIntervalForResource：响应的超时时长</li><li>requestCachePolicy：缓存策略</li></ul><blockquote><p><strong>注意事项:如果是自定义会话并指定了代理，会话会对代理进行强引用,在视图控制器销毁之前，需要取消网络会话，否则会造成内存泄漏</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、URL-Session的基本概念&quot;&gt;&lt;a href=&quot;#一、URL-Session的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、URL Session的基本概念&quot;&gt;&lt;/a&gt;一、URL Session的基本概念&lt;/h2&gt;&lt;h3 id=&quot;1</summary>
      
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中的BOOL类型</title>
    <link href="http://yoursite.com/2018/03/22/Objective-C%E4%B8%AD%E7%9A%84BOOL%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/22/Objective-C%E4%B8%AD%E7%9A%84BOOL%E7%B1%BB%E5%9E%8B/</id>
    <published>2018-03-22T02:30:31.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C中的BOOL类型在Watch和64位iOS上的原始类型为bool，而在其它情况下是<code>signed char</code>。我们用<code>@encode</code>去看看BOOL的类型串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@encode(BOOL)// 64位iOS系统：&quot;B&quot;</span><br><span class="line">@encode(BOOL)// 32位iOS系统，32/64位OS X：&quot;c&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有这边有一个问题，下面这段代码中变量b的值在不同环境下，其结果可能是不一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOL a = 100 &amp; 20;</span><br><span class="line">BOOL b = (a == YES);</span><br></pre></td></tr></table></figure><p>当BOOL为bool时，b的值为1；而当BOOL为<code>signed char</code>时，b的值为0。所以，如果我们判断一个BOOL值是否为真时，不应该通过<code>if(a == YES)</code>这种方式来判断，要么直接就<code>if (a)</code>，要么就<code>if (a != NO)</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Objective-C中的BOOL类型在Watch和64位iOS上的原始类型为bool，而在其它情况下是&lt;code&gt;signed char&lt;/code&gt;。我们用&lt;code&gt;@encode&lt;/code&gt;去看看BOOL的类型串：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>UIImageView显示gif图片有两种方式</title>
    <link href="http://yoursite.com/2018/03/22/UIImageView%E6%98%BE%E7%A4%BAgif%E5%9B%BE%E7%89%87%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/22/UIImageView%E6%98%BE%E7%A4%BAgif%E5%9B%BE%E7%89%87%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2018-03-22T02:30:31.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>UIImageView显示gif图片有两种方式。当然前提都是先将gif中的每一帧取出来放到一个个UIImage对象中，将这些对象放到一个数组中，如下代码所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</span><br><span class="line">size_t count = CGImageSourceGetCount(source);</span><br><span class="line">    </span><br><span class="line">NSMutableArray *images = [NSMutableArray array];</span><br><span class="line">for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">   CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line">   [images addObject:[UIImage imageWithCGImage:image scale:[UIScreen mainScreen] orientation:UIImageOrientationUp]];</span><br><span class="line">   CGImageRelease(image);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">CFRelease(source)</span><br></pre></td></tr></table></figure><p>一种方式是将这些UIImage对象通过UIImage的类方法+animatedImageWithImages:duration:组合成一个UIImage对象，然后赋值给UIImageView对象的image属性。</p><p>第二种方式是将UIImage对象的数组赋值给UIImageView对象的animationImages属性，然后调用UIImageView对象的startAnimating方法来启动动画。</p><p>当然，两种方式都需要计算duration。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UIImageView显示gif图片有两种方式。当然前提都是先将gif中的每一帧取出来放到一个个UIImage对象中，将这些对象放到一个数组中，如下代码所示。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>URL转义</title>
    <link href="http://yoursite.com/2018/03/22/URL%E8%BD%AC%E4%B9%89/"/>
    <id>http://yoursite.com/2018/03/22/URL%E8%BD%AC%E4%B9%89/</id>
    <published>2018-03-22T02:30:31.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>在使用<code>+URLWithString:</code>或<code>-initWithString:</code>来创建一个URL对象时，提供的参数字符串必须符合RFC 2396标准<a href="https://www.ietf.org/rfc/rfc2396.txt">Uniform Resource Identifiers (URI): Generic Syntax</a>。而这两个方法又是根据RFC 1738 <a href="https://www.ietf.org/rfc/rfc1738.txt">Uniform Resource Locators (URL)</a>和1808 <a href="https://www.ietf.org/rfc/rfc1808.txt">Relative Uniform Resource Locators</a>两个标准来解析字符串的。故弄玄虚一下。当然我们不需要去了解所有的细节，简单了解一下就行，可以参考一下阮大侠的这篇关于URL编码。</p><p>这里要说明的就是：对于我们而言，如果用带有中文的字符串(如“<a href="https://www.baidu.com?q=北京">https://www.baidu.com?q=北京</a>”)去创建一个URL对象的话，返回的是一个nil。</p><p>我们所需要做的就是对不符合标准的字符串进行转义操作。<code>NSString</code>类提供了两个方法来做这种转义操作，一个是<code>-stringByAddingPercentEscapesUsingEncoding:</code>，不过这个方法在iOS 9.0已被废弃；现在更提倡的是用<code>-stringByAddingPercentEncodingWithAllowedCharacters:</code>方法，这个方法是iOS 7.0后添加的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlStr = [@&quot;https://www.baidu.com?q=北京&quot; stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用&lt;code&gt;+URLWithString:&lt;/code&gt;或&lt;code&gt;-initWithString:&lt;/code&gt;来创建一个URL对象时，提供的参数字符串必须符合RFC 2396标准&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.</summary>
      
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Runtime的几点用法总结</title>
    <link href="http://yoursite.com/2018/03/10/Runtime%E7%9A%84%E5%87%A0%E7%82%B9%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/10/Runtime%E7%9A%84%E5%87%A0%E7%82%B9%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2018-03-10T08:30:56.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="runtime简介"><a href="#runtime简介" class="headerlink" title="runtime简介"></a>runtime简介</h2><ul><li>RunTime简称运行时。OC就是<strong><em>运行时机制</em></strong>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li><li>对于C语言，<strong><em>函数的调用在编译的时候会决定调用哪个函数</em></strong>。</li><li>对于OC的函数，属于<strong><em>动态调用过程</em></strong>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li><li>事实证明：<ul><li>在编译阶段，OC可以<strong><em>调用任何函数</em></strong>，即使这个函数并未实现，只要声明过就不会报错。</li><li>在编译阶段，C语言调用<strong><em>未实现的函数</em></strong>就会报错。<span id="more"></span></li></ul></li></ul><h2 id="给类别Category添加属性"><a href="#给类别Category添加属性" class="headerlink" title="给类别Category添加属性"></a>给类别Category添加属性</h2><p>比如说我们需要在类别中添加一个NSString类型的属性，直接在.h文件添加 <strong>@property(nonatomic,copy) NSString*categoryProperty;</strong> 这时候使用点语法进行调用的话，程序会出现crash错误:<strong><em>Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[ViewController setCategoryProperty:]: unrecognized selector sent to instance 0x7ff661e43dd0’</em></strong>。这种状况的原因其实很简单，只是没有实现setter和getter方法而已，所以我们的问题就转为实现setter 和 getter方法。<br>一言不合就要上代码了，主要记录两种类型数据的处理方式。例子为给UIImage添加了两个属性，没什么具体含义，主要记录用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">@interface UIImage (MNZAdd)</span><br><span class="line"></span><br><span class="line">@property(nonatomic,strong) NSString *name;</span><br><span class="line">@property(nonatomic,assign) CGFloat add;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">//.m</span><br><span class="line">#import &quot;UIImage+ MNZAdd.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIImage (MNZAdd)</span><br><span class="line">#pragma mark - 添加属性</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    [self willChangeValueForKey:NSStringFromSelector(@selector(name))];</span><br><span class="line">    objc_setAssociatedObject(self, _cmd, name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">    [self didChangeValueForKey:NSStringFromSelector(@selector(name))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(setName:));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setAdd:(CGFloat)add</span><br><span class="line">&#123;</span><br><span class="line">    [self willChangeValueForKey:NSStringFromSelector(@selector(add))];</span><br><span class="line"></span><br><span class="line">    //区别在这里，区别在这里</span><br><span class="line">    NSValue *value = [NSValue value:&amp;add withObjCType:@encode(CGFloat)];</span><br><span class="line">    objc_setAssociatedObject(self, _cmd, value, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"></span><br><span class="line">    [self didChangeValueForKey:NSStringFromSelector(@selector(add))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)add</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat cValue = &#123;0&#125;;</span><br><span class="line">    NSValue *value = objc_getAssociatedObject(self, @selector(setAdd:));</span><br><span class="line">    [value getValue:&amp;cValue];</span><br><span class="line">    return cValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="利用runtime来替换已有的系统方法"><a href="#利用runtime来替换已有的系统方法" class="headerlink" title="利用runtime来替换已有的系统方法"></a>利用runtime来替换已有的系统方法</h2><p>例子，初始化UIImage的时候，在不同的系统版本中添加不同的风格的切图，怎么就是和UIImage过不去了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UIImage (MNZAdd)</span><br><span class="line">/*!</span><br><span class="line"> @brief 如果调用这个，其实调用的是原来系统的方法，因为他两交换了实现</span><br><span class="line"></span><br><span class="line"> @note 为防止误用，可以不声明该方法</span><br><span class="line"> */</span><br><span class="line">+ (nonnull UIImage *)mnz_imageNamed:(NSString *)name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//.m</span><br><span class="line">#import &quot;UIImage+MNZAdd.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIImage (MNZAdd)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = @selector(imageNamed:);</span><br><span class="line">        SEL mySelector = @selector(mnz_imageNamed:);</span><br><span class="line">        /*</span><br><span class="line">            //实例方法</span><br><span class="line">            Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">            Method myMethod = class_getInstanceMethod(class, mySelector);</span><br><span class="line">         */</span><br><span class="line">        Method originalMethod = class_getClassMethod(class, originalSelector);</span><br><span class="line">        Method myMethod = class_getClassMethod(class, mySelector);</span><br><span class="line">        </span><br><span class="line">        class_addMethod(class, originalSelector, class_getMethodImplementation(class, originalSelector), method_getTypeEncoding(originalMethod));</span><br><span class="line">        class_addMethod(class, mySelector, class_getMethodImplementation(class, mySelector), method_getTypeEncoding(myMethod));</span><br><span class="line">        //交换方法的实现</span><br><span class="line">        method_exchangeImplementations(originalMethod, myMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 交换系统方法</span><br><span class="line">+ (nonnull UIImage *)mnz_imageNamed:(NSString *)name &#123;</span><br><span class="line">    /*!</span><br><span class="line">     在这里实现我们所需要做的操作</span><br><span class="line">     */</span><br><span class="line">    double systemVersion = [[[UIDevice currentDevice]systemVersion] floatValue];</span><br><span class="line">    if (systemVersion &gt;= 9.0) &#123;</span><br><span class="line">        name = [name stringByAppendingString:@&quot;_os&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    //这个地方很关键，mnz_imageNamed:是调用系统的imageNamed:实现(两个方法交换了实现)</span><br><span class="line">    UIImage *image = [UIImage mnz_imageNamed:name];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法+ (void)load不是这里的重点，简单知道一下：一般情况下，类别中的方法会重写掉主类里面相同命名的方法，但+load:是个特例，当一个类被读到内存的时候，runtime会给这个类以及他的每一个类别都发送一个 +load:消息(知道这一点很重要)。<br><strong>Note：注意交换方法只能执行一次，不要总是执行，load的意义在这儿也有体现的。</strong></p><p>还有一点是，尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但是其父类实现了，那么 class_getInstanceMethod 返回的将是父类的方法。这样就导致了 method_exchangeImplementations 替换的是父类的方法。所以先尝试添加 originalSelector ，如果已经存在，再用 method_exchangeImplementations 把原来的方法的实现交换成新方法的实现。</p><h2 id="实现自动归档和自动解档"><a href="#实现自动归档和自动解档" class="headerlink" title="实现自动归档和自动解档"></a>实现自动归档和自动解档</h2><p>其实归档的实现很简单，只不过就是实现协议<NSCoding>，需要说明一点的是： <strong>实现了 ‘NSCoding’协议，就可以支持数据类和数据流间的编码和解码，而数据流可以持久化到硬盘。</strong></NSCoding></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MNZEncodeModel : NSObject&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,strong) NSString *name;</span><br><span class="line">@property(nonatomic,assign) int age;</span><br><span class="line">@property(nonatomic,assign) NSRange range;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//.m</span><br><span class="line">#import &quot;MNZEncodeModel.h&quot;</span><br><span class="line">#import &quot;NSObject+MNZEncode.h&quot;</span><br><span class="line"></span><br><span class="line">NSString *const kEncodeName = @&quot;name&quot;;</span><br><span class="line">NSString *const kEncodeAge = @&quot;age&quot;;</span><br><span class="line">NSString *const kEncodeRange = @&quot;range&quot;;</span><br><span class="line"></span><br><span class="line">@implementation MNZEncodeModel</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _name = [aDecoder decodeObjectForKey:kEncodeName];</span><br><span class="line">        _age = [aDecoder decodeIntForKey:kEncodeAge];</span><br><span class="line">        _range = [[aDecoder decodeObjectForKey:kEncodeRange] rangeValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    [aCoder encodeObject:self.name forKey:kEncodeName];</span><br><span class="line">    [aCoder encodeInt:self.age forKey:kEncodeAge];</span><br><span class="line">    [aCoder encodeObject:[NSValue valueWithRange:self.range] forKey:kEncodeRange];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可问题在于，像这样只有三个属性需要我们，可以这样写，那如果有三十个属性呐，身为一个会偷懒的程序员自然要找偷懒的方法了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MNZEncodeModel : NSObject &lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,strong) NSString *name;</span><br><span class="line">@property(nonatomic,assign) int age;</span><br><span class="line">@property(nonatomic,assign) NSRange range;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//.m</span><br><span class="line">#import &quot;MNZEncodeModel.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation MNZEncodeModel</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)coder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        unsigned int count = 0;</span><br><span class="line">        Ivar *ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">        for (int i=0; i&lt;count; i++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            const char *name = ivar_getName(ivar);</span><br><span class="line">            NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">            id value = [coder decodeObjectForKey:key];</span><br><span class="line">            [self setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    for (int i=0; i&lt;count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">        id value = [self valueForKey:key];</span><br><span class="line">        [aCoder encodeObject:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>简化一下使用方式</strong></p><p>而这样每一个模型类都要写着无聊的代码，而大部分类都是继承自NSObject，所以，我们可以实现一个NSObject类别来专门做这件事。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSObject (MNZEncode)</span><br><span class="line"></span><br><span class="line">- (instancetype)mnz_initWithCoder:(NSCoder *)aDecoder;</span><br><span class="line">- (void)mnz_encodeWithCoder:(NSCoder *)aCoder;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//.m</span><br><span class="line"></span><br><span class="line">#import &quot;NSObject+MNZEncode.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (MNZEncode)</span><br><span class="line"></span><br><span class="line">- (instancetype)mnz_initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    if (!aDecoder) return self;</span><br><span class="line">    if (self == (id)kCFNull) return self;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        //取出i对应位置的成员变量</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        //查看成员变量</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        //归档</span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">        id value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">        //设置到成员变量身上</span><br><span class="line">        [self setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mnz_encodeWithCoder:(NSCoder *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    if (!aCoder) return;</span><br><span class="line">    if (self == (id)kCFNull) &#123;</span><br><span class="line">        [((id&lt;NSCoding&gt;)self)encodeWithCoder:aCoder];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">        id value = [self valueForKey:key];</span><br><span class="line">        [aCoder encodeObject:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这样在使用的时候只需要简单的引用一下就可以了</p><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p><strong>objc_msgSend</strong>方法的使用</p><pre><code>objc_msgSend(receiver,selector)</code></pre><p>或者传入参数</p><pre><code>objc_msgSend(receiver,selector,arg1,arg2,...)</code></pre><p>对于一个给定的函数调用，如</p><pre><code>[self SendImage:fileName];</code></pre><p>可以通过如下方法来替换：</p><pre><code>void (*action)(id, SEL, NSString*) = (void (*)(id, SEL, NSString*))objc_msgSend;action(self, @selector(SendImage:), fileName);</code></pre><p>注意objc_msgSend函数总是以一个id变量和一个selector作为它的前两个参数。objc_msgSend 被转换成函数指针后，就可以通过这个函数指针进行函数调用了。</p><p>当一个message被发送给object，会根据object的isa 指针找到类结构里的方法，如果不能找到，一直顺着父类寻找该方法的实现，直到NSObject类。</p><p>为加快速度，runtime system 会缓存使用过的selector和方法地址。 </p><ul><li>通过object的isa指针找到他的class</li><li>在class的method_list中找到方法</li><li>如果class中没有找到方法，继续往superclass中查找</li><li>一旦找到这个函数，执行对应的方法实现 （IMP）</li><li>找不到 Dynamic Method Resolution(动态方法决议) 如果是实例方法，调用<strong>+ (BOOL)resolveInstanceMethod:(SEL)sel,</strong>如果是类方法，调用<strong>+ (BOOL)resolveClassMethod:(SEL)sel，</strong>这样可以让程序在运行时动态的为一个selector提供实现。如果返回YES，运行时系统会重启一次消息的发送过程，调动动态添加方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">  if (sel == @selector(foo)) &#123;</span><br><span class="line">      class_addMethod([self class], sel, (IMP)dynamicMethodIMP, &quot;V@:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">void dynamicMethodIMP(id self,SEL _cmd)&#123;</span><br><span class="line">  NSLog(@&quot;%s&quot;,__PRETTY_FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">+(BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">  return [super resolveClassMethod:sel];</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p><strong>Note：Objective-C的方法本质上是一个至少包含了两个参数（id self,SEL _cmd)的C函数。</strong></p><h3 id="Message-Forwarding（消息转发）"><a href="#Message-Forwarding（消息转发）" class="headerlink" title="Message Forwarding（消息转发）"></a>Message Forwarding（消息转发）</h3><p>分两步：<br>1、首先运行时系统会调用- (id)forwardingTargetForSelector:(SEL)aSelector方法，如果这个方法中返回的不是nil或者self，运行时系统将把消息发送给返回的那个对象<br>2、如果- (id)forwardingTargetForSelector:(SEL)aSelector返回的是nil或者self，运行时系统首先会调用- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector方法来获得方法签名，方法签名记录了方法的参数和返回值的信息，如果－methodSignatureForSelector 返回的是nil, 运行时系统会抛出unrecognized selector exception，程序到这里就结束了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">  NSMethodSignature *signature =[super methodSignatureForSelector:aSelector];</span><br><span class="line">  if (!signature) &#123;</span><br><span class="line">      //获取指定对象的方法签名</span><br><span class="line">      signature = [target methodSignatureForSelector:aSelector];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">  //检测target是否实现来该方法</span><br><span class="line">  if ([target respondsToSelector:anInvocation.selector]) &#123;</span><br><span class="line">      //如果实现了，在这儿将方法分发到对象中去 。可利用这个实现多重代理</span><br><span class="line">      [anInvocation invokeWithTarget:target];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">  return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 第一步：我们不动态添加方法，返回NO，进入第二步；</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二部：我们不指定备选对象响应aSelector，进入第三步；</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第三步：返回方法选择器，然后进入第四部；</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector </span><br><span class="line">&#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;sing&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第四部：这步我们修改调用对象</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation </span><br><span class="line">&#123;</span><br><span class="line">    // 我们改变调用对象为People</span><br><span class="line">    NewClass *newTarget = [[NewClass alloc] init];</span><br><span class="line">    [anInvocation invokeWithTarget:newTarget];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/412094-06902bf5c47bb62e.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="流程图"></p><h2 id="几个特殊方法"><a href="#几个特殊方法" class="headerlink" title="几个特殊方法"></a>几个特殊方法</h2><p><strong>objc_msgSend_stret</strong><br>如果待发送的消息要返回结构体，那么可交由此函数处理。只有当CPU的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于CPU寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</p><p><strong>objc_msgSend_fpret</strong><br>如果消息返回的是浮点数，那么可交由此函数处理。在某些架构的CPU中调用函数时，需要对“浮点数寄存器”（floating-point register）做特殊处理，也就是说，通常所用的objc_msgSend在这种情况下并不合适。这个函数是为了处理x86等架构CPU中某些令人稍觉惊讶的奇怪状况。</p><p><strong>objc_msgSendSuper</strong><br>如果要给超类发消息，例如[super message:parameter]，那么就交由此函数处理。也有另外两个与objc_msgSend_stret和objc_msgSend_fpret等效的函数，用于处理发给super的相应消息。</p><p>上文说过，当找到相应的方法时，会跳转过去。之所以可以这样实现，是因为每一个Objective-C函数都可以看作是一个简单的C函数，原型如下：</p><pre><code>&lt;return_type&gt; Class_selector(id self,SEL _cmd,...)</code></pre><p>以上Class及selector的命名是为了方便理解。每个类中都有一张类似于字典的方法表，而selector就相当于查找方法的key，objc_msgSend函数就是通过查这张表来实现跳转的。之所以以上原型和objc_msgSend方法长的非常相像，是为了更好使用tail-call技术来时方法的跳转更加优化。</p><p>如果某函数的最后一项操作是调用另外一个函数，那么就可以运用“tail-call”技术。<br>此时编译器会生成调转至另一函数所需的指令码，而不会向调用堆栈中推入新的“栈帧”。tail-call使用的条件比较苛刻，除了要求函数的最后一项操作是调用另外一个函数外，，并且要求另外一个函数不是有返回值的函数类型。tail-call对objc_msgSend非常关键，如果不这么做的话，那么每次调用Objective-C方法之前，都需要为调用objc_msgSend函数准备“栈帧”，若是不优化，还会过早地发生“栈溢出”（stack overflow）现象。</p><p>在写OC中，我们其实并不需要了解那么多底层的东西，但是我们需要知道调用一个方法之后，OC底层都发生了什么。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>1、一个消息包含接受者，选择子和参数。调用一个方法相当于像对象发送一条消息。<br>2、当发送消息是，动态绑定机制会帮助我们查找方法的实现并进行运行。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;runtime简介&quot;&gt;&lt;a href=&quot;#runtime简介&quot; class=&quot;headerlink&quot; title=&quot;runtime简介&quot;&gt;&lt;/a&gt;runtime简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;RunTime简称运行时。OC就是&lt;strong&gt;&lt;em&gt;运行时机制&lt;/em&gt;&lt;/strong&gt;，也就是在运行时候的一些机制，其中最主要的是消息机制。&lt;/li&gt;
&lt;li&gt;对于C语言，&lt;strong&gt;&lt;em&gt;函数的调用在编译的时候会决定调用哪个函数&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;对于OC的函数，属于&lt;strong&gt;&lt;em&gt;动态调用过程&lt;/em&gt;&lt;/strong&gt;，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。&lt;/li&gt;
&lt;li&gt;事实证明：&lt;ul&gt;
&lt;li&gt;在编译阶段，OC可以&lt;strong&gt;&lt;em&gt;调用任何函数&lt;/em&gt;&lt;/strong&gt;，即使这个函数并未实现，只要声明过就不会报错。&lt;/li&gt;
&lt;li&gt;在编译阶段，C语言调用&lt;strong&gt;&lt;em&gt;未实现的函数&lt;/em&gt;&lt;/strong&gt;就会报错。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>GCD-semaphore</title>
    <link href="http://yoursite.com/2018/03/03/GCD/"/>
    <id>http://yoursite.com/2018/03/03/GCD/</id>
    <published>2018-03-03T02:30:31.000Z</published>
    <updated>2023-05-27T14:37:22.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要应用："><a href="#主要应用：" class="headerlink" title="主要应用："></a>主要应用：</h3><blockquote><ol><li>保持线程同步</li><li>为线程加锁</li></ol></blockquote><p><img src="/2018/03/03/GCD/938554-0719e15ecc9c438c.webp" alt="图片"></p><span id="more"></span><h4 id="保持线程同步"><a href="#保持线程同步" class="headerlink" title="保持线程同步"></a>保持线程同步</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * semaphore 线程同步</span><br><span class="line"> */</span><br><span class="line">- (void)semaphoreSync &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    __block int number = 0;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">        number = 100;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;semaphore---end,number = %zd&quot;,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为线程加锁"><a href="#为线程加锁" class="headerlink" title="为线程加锁"></a>为线程加锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 semaphore 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line">- (void)initTicketStatusSave &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">    NSLog(@&quot;semaphore---begin&quot;);</span><br><span class="line">    semaphoreLock = dispatch_semaphore_create(1);</span><br><span class="line">    self.ticketSurplusCount = 50;</span><br><span class="line">    // queue1 代表北京火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // queue2 代表上海火车票售卖窗口</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 相当于加锁</span><br><span class="line">        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;  //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123; //如果已卖完，关闭售票窗口</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            // 相当于解锁</span><br><span class="line">            dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 相当于解锁</span><br><span class="line">        dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;主要应用：&quot;&gt;&lt;a href=&quot;#主要应用：&quot; class=&quot;headerlink&quot; title=&quot;主要应用：&quot;&gt;&lt;/a&gt;主要应用：&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;保持线程同步&lt;/li&gt;
&lt;li&gt;为线程加锁&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/03/GCD/938554-0719e15ecc9c438c.webp&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS如何给没有数据的cell隐藏分割线</title>
    <link href="http://yoursite.com/2018/02/15/iOS%E5%A6%82%E4%BD%95%E7%BB%99%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84cell%E9%9A%90%E8%97%8F%E5%88%86%E5%89%B2%E7%BA%BF/"/>
    <id>http://yoursite.com/2018/02/15/iOS%E5%A6%82%E4%BD%95%E7%BB%99%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84cell%E9%9A%90%E8%97%8F%E5%88%86%E5%89%B2%E7%BA%BF/</id>
    <published>2018-02-15T03:26:27.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景-例如搜索时候只有一条数据-其他空白cell分割线隐藏起来"><a href="#应用场景-例如搜索时候只有一条数据-其他空白cell分割线隐藏起来" class="headerlink" title="应用场景:例如搜索时候只有一条数据,其他空白cell分割线隐藏起来"></a>应用场景:例如搜索时候只有一条数据,其他空白cell分割线隐藏起来</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView *view = [[UIView alloc] init];</span><br><span class="line">[view setBackgroundColor:[UIColor clearColor]];</span><br><span class="line">self.tableView.tableFooterView = view;</span><br></pre></td></tr></table></figure><h3 id="为了方便其他地方用-可以给tableView写分类"><a href="#为了方便其他地方用-可以给tableView写分类" class="headerlink" title="为了方便其他地方用,可以给tableView写分类"></a>为了方便其他地方用,可以给tableView写分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface UITableView (Additions)</span><br><span class="line">- (void)mnz_hideTableEmptyDataSeparatorLine;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)mnz_hideTableEmptyDataSeparatorLine &#123;</span><br><span class="line">    UIView *view = [[UIView alloc] init];</span><br><span class="line">    [view setBackgroundColor:[UIColor clearColor]];</span><br><span class="line">    self.tableFooterView = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;应用场景-例如搜索时候只有一条数据-其他空白cell分割线隐藏起来&quot;&gt;&lt;a href=&quot;#应用场景-例如搜索时候只有一条数据-其他空白cell分割线隐藏起来&quot; class=&quot;headerlink&quot; title=&quot;应用场景:例如搜索时候只有一条数据,其他空白cell</summary>
      
    
    
    
    <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo搭建免费个人博客</title>
    <link href="http://yoursite.com/2018/02/09/Github+Hexo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/02/09/Github+Hexo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-02-09T09:30:31.000Z</published>
    <updated>2023-05-27T11:58:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>经过各种找资料，踩过各种坑，终于搭建好了hexo，域名目前用的是github的，我的hexo是3.5.0版本，hexo不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>这篇教程是针对Mac的，之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力。一个技术点我们会使用，并不难，但是要做到让别人也能听懂，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢，简书还算好点（我的文章在简书上也有同步）。最近看到一些大神们的博客，貌似都是用hexo写的，我也依葫芦画瓢的搭建了一个。不啰嗦了，直接上搭建步骤。</p><span id="more"></span><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><h4 id="安装Node-js（必须）"><a href="#安装Node-js（必须）" class="headerlink" title="安装Node.js（必须）"></a>安装Node.js（必须）</h4><p>作用：用来生成静态页面。<br>到Node.js<a href="https://nodejs.org/en/">官网</a>下载相应平台的最新版本，按照提示一路安装即可。</p><h4 id="安装Git（必须）"><a href="#安装Git（必须）" class="headerlink" title="安装Git（必须）"></a>安装Git（必须）</h4><p>作用：把本地的hexo内容提交到github上去。<br>如果已经安装了Xcode就自带Git，我就不多说了。</p><h4 id="申请GitHub（必须）"><a href="#申请GitHub（必须）" class="headerlink" title="申请GitHub（必须）"></a>申请GitHub（必须）</h4><p>作用：是用来做博客的远程仓库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。<br><a href="https://github.com/">Github</a>账号我也不再啰嗦了，没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配置，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，假如配置了就不需要了，怎么配置我就不多说了，网上有很多教程。</p><h3 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a>开始安装Hexo</h3><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>Node.js和Git都安装好后，可执行如下命令安装hexo：</p><pre><code>$ sudo npm install -g hexo</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>然后，执行init命令初始化hexo到你指定的目录，我是直接cd到目标，在目录里执行如下命令:</p><pre><code>$ hexo init</code></pre><p>好啦，至此，全部安装工作已经完成！</p><h4 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h4><p>cd 到你的init目录，执行如下命令，生成静态页面至public目录。</p><pre><code>$ hexo generate（hexo g也可以）</code></pre><h4 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h4><p>启动本地服务，进行文章预览调试，命令：</p><pre><code>$ hexo server</code></pre><p>在浏览器中输入:<a href="http://localhost:4000">http://localhost:4000</a></p><p>可能报的一些错，和解决方式列出来：</p><p>1&gt;</p><pre><code>FATAL Cannot find module &apos;/Users/xxxxxxx/GitHubBlog/1170197998.github.io/node_modules/hexo-renderer-marked&apos;</code></pre><p>可能是安装hexo的时候没有执行npm install，执行如下命令：</p><pre><code>rm -rf node_modulesnpm install</code></pre><p>2&gt;ERROR Deployer not found : github的问题解决办法</p><p>先执行：</p><pre><code>npm install hexo-deployer-git --save </code></pre><p>然后执行：</p><pre><code>hexo g hexo d </code></pre><p>3&gt;</p><pre><code>ERROR Plugin load failed: hexo-server</code></pre><p>原因：</p><pre><code>Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.</code></pre><p>解决方法，执行命令：</p><pre><code>$ sudo npm install hexo-server --save</code></pre><p>安装完成后，输入以下命令以启动服务器，您的网站会在 <a href="http://localhost:4000">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>这个时候再重新生成静态文件，命令：</p><pre><code>$ hexo generate（或hexo g）</code></pre><p>启动本地服务器：</p><pre><code>$ hexo server</code></pre><p>如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：</p><pre><code>$ hexo server -p 5000</code></pre><h3 id="配置-Github"><a href="#配置-Github" class="headerlink" title="配置 Github"></a>配置 Github</h3><h4 id="建立Repository"><a href="#建立Repository" class="headerlink" title="建立Repository"></a>建立Repository</h4><p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法。然后建立关联，我的blog在本地/Users/chenhu/Documents/Hexo，这里面有：</p><pre><code>_config.yml    node_modules    public        source　　　　db.json        package.json    scaffolds    themes</code></pre><p>现在我们需要修改_config.yml文件来建立关联，命令：</p><pre><code>$ vim _config.yml</code></pre><p>翻到最下面，改成类似我这样子</p><pre><code>deploy:    type: git    repository: https://github.com/chenhu1001/chenhu1001.github.io.git    branch: master</code></pre><p> 执行如下命令才能使用git部署</p><pre><code>$ sudo npm install hexo-deployer-git --save</code></pre><p>网上会有很多说法，有的type是github，还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo:3.5.0，执行命令hexo -version就出来了，貌似3.0以后全部改成我上面这种格式了。<br>然后，执行配置命令：</p><pre><code>$ hexo deploy</code></pre><p>然后再浏览器中输入<a href="https://mnz12138.github.io就行了，我的github账户叫mnz12138，把这个改成你github的账户名就行了。">https://mnz12138.github.io就行了，我的github账户叫mnz12138，把这个改成你github的账户名就行了。</a></p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>每次部署的步骤，可按以下三步来进行。</p><pre><code>hexo clean  hexo generate  hexo deploy</code></pre><p>还可以将上面的3个命令封装成一个shell脚本（publish.sh），放在Hexo对应的目录下方便上传部署。</p><h4 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h4><p>hexo new “postName”   //新建文章<br>hexo new page “pageName”   //新建页面<br>hexo generate   //生成静态页面至public目录<br>hexo server   //开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy   //将Hexo部署到GitHub<br>hexo help   //查看帮助<br>hexo version   //查看Hexo的版本<br>&amp;emsp;&amp;emsp;   //段落前空两格(为了显示，没有转移符)<br>&lt;!–more–&gt;   //用于文章的隔断，显示更多<br>[iOS,WebRTC,直播,FFMpeg]   //用于写文章时增加tag  </p><h4 id="Hexo-设置阅读全文"><a href="#Hexo-设置阅读全文" class="headerlink" title="Hexo-设置阅读全文"></a>Hexo-设置阅读全文</h4><blockquote><ol><li>在文章中使用<code>&lt;!--more--&gt;</code>手动进行截断</li><li>在文章中的front-matter中添加description，并提供文章摘录<br>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。</li><li>自动形成摘要，在主题配置文件中添加<br>默认截取的长度为 150 字符，可以根据需要自行设定</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:  </span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><h4 id="建议使用-lt-more-gt-（即第一种方式），除了可以精确控制需要显示的摘录内容以外，-这种方式也可以让-Hexo-中的插件更好的识别。"><a href="#建议使用-lt-more-gt-（即第一种方式），除了可以精确控制需要显示的摘录内容以外，-这种方式也可以让-Hexo-中的插件更好的识别。" class="headerlink" title="建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。"></a>建议使用 <code>&lt;!-- more --&gt;</code>（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。</h4><h4 id="一些基本路径"><a href="#一些基本路径" class="headerlink" title="一些基本路径"></a>一些基本路径</h4><p>文章在source/_posts下，支持Markdown语法，可以用Markdown编辑器进行编辑，如果想修改头像可以直接在主题的_config.yml文件里面修改，友情链接之类的都在这里，开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。</p><h3 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h3><p><a href="https://www.zybuluo.com/mdeditor">实用的Markdown语法例子</a></p><p>mnz12138的技术博客：<a href="https://mnz12138.github.io">https://mnz12138.github.io</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;经过各种找资料，踩过各种坑，终于搭建好了hexo，域名目前用的是github的，我的hexo是3.5.0版本，hexo不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h3&gt;&lt;p&gt;这篇教程是针对Mac的，之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力。一个技术点我们会使用，并不难，但是要做到让别人也能听懂，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢，简书还算好点（我的文章在简书上也有同步）。最近看到一些大神们的博客，貌似都是用hexo写的，我也依葫芦画瓢的搭建了一个。不啰嗦了，直接上搭建步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
