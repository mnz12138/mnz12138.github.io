<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言Swift type System  Swift是强类型的，尽管只有六种类型。  命名类型： protocol, class , struct , enum 复合类型：tuple, function   可能会有疑问，那些基本类型：Bool，Int，UInt, Float, Double, Character, String, Array, Set, Dictionary, Optional。">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift中enum、struct、class">
<meta property="og:url" content="http://yoursite.com/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/index.html">
<meta property="og:site_name" content="Marks">
<meta property="og:description" content="前言Swift type System  Swift是强类型的，尽管只有六种类型。  命名类型： protocol, class , struct , enum 复合类型：tuple, function   可能会有疑问，那些基本类型：Bool，Int，UInt, Float, Double, Character, String, Array, Set, Dictionary, Optional。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1363078-2e345f512c635c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="article:published_time" content="2018-04-01T05:01:17.000Z">
<meta property="article:modified_time" content="2023-05-27T11:58:43.410Z">
<meta property="article:author" content="Marks - 上海">
<meta property="article:tag" content="Swift">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1363078-2e345f512c635c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">

<link rel="canonical" href="http://yoursite.com/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Swift中enum、struct、class | Marks</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Marks" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Marks</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">iOS开发者，喜欢研究技术。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/Swift%E4%B8%ADenum%E3%80%81struct%E3%80%81class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Marks - 上海">
      <meta itemprop="description" content="小码农的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marks">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift中enum、struct、class
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-01 13:01:17" itemprop="dateCreated datePublished" datetime="2018-04-01T13:01:17+08:00">2018-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-27 19:58:43" itemprop="dateModified" datetime="2023-05-27T19:58:43+08:00">2023-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Swift type System</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1363078-2e345f512c635c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图片"></p>
<p>Swift是强类型的，尽管只有六种类型。</p>
<ul>
<li>命名类型： protocol, class , struct , enum</li>
<li>复合类型：tuple, function</li>
</ul>
<blockquote>
<p>可能会有疑问，那些基本类型：Bool，Int，UInt, Float, Double, Character, String, Array, Set, Dictionary, Optional。实际上他们都是通过命名类型创建的。</p>
</blockquote>
<h3 id="Struct-Class-and-Enum-对比"><a href="#Struct-Class-and-Enum-对比" class="headerlink" title="Struct Class and Enum 对比"></a>Struct Class and Enum 对比</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">copy by</th>
<th align="center">inheritance</th>
<th align="center">static variable</th>
<th align="center">instance variable</th>
<th align="center">static method</th>
<th align="center">instance method</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Class</td>
<td align="center">Reference</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Struct</td>
<td align="center">Value</td>
<td align="center">✘</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">Enum</td>
<td align="center">Value</td>
<td align="center">✘</td>
<td align="center">✅</td>
<td align="center">✘</td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
</tbody></table>
<h4 id="枚举、结构体、类的共同点："><a href="#枚举、结构体、类的共同点：" class="headerlink" title="枚举、结构体、类的共同点："></a>枚举、结构体、类的共同点：</h4><ul>
<li>定义属性和方法；</li>
<li>下标语法访问值；</li>
<li>初始化器；</li>
<li>支持扩展增加功能；</li>
<li>可以遵循协议；</li>
<li>都可以使用泛型；</li>
</ul>
<h4 id="类特有的功能："><a href="#类特有的功能：" class="headerlink" title="类特有的功能："></a>类特有的功能：</h4><ul>
<li>继承；</li>
<li>允许类型转换；</li>
<li>析构方法释放资源；</li>
<li>引用计数；</li>
</ul>
<span id="more"></span>

<h3 id="如何抉择？"><a href="#如何抉择？" class="headerlink" title="如何抉择？"></a>如何抉择？</h3><p>通常，在平时的编程中，按照对象的生命周期形态，可以把使用的类型分成两大类：</p>
<ul>
<li><strong>一类必须有明确生命周期的，它们必须被明确的初始化、使用、最后明确的被释放。</strong>例如：文件句柄、数据库连接、线程同步锁等等。这些类型的初始化和释放都不是拷贝内存这么简单，通常，这类内容，我们会选择使用<code>class</code>来实现。</li>
<li><strong>另一类，则是没有那么明显的生命周期。</strong>例如：整数、字符串、URL等等。这些对象一旦被创建之后，就很少被修改，我们只是需要使用这些对象的值，用完之后，我们也无需为这些对象的销毁做更多额外的工作，只是把它们占用的内存回收就好了。这类内容，通常我们会选择使用<code>struct</code>或<code>enum</code>来实现。</li>
</ul>
<h4 id="什么时候该用值类型："><a href="#什么时候该用值类型：" class="headerlink" title="什么时候该用值类型："></a>什么时候该用值类型：</h4><ul>
<li>要用==运算符来比较实例的数据时</li>
<li>你希望那个实例的拷贝能保持独立的状态时</li>
<li>数据会被多个线程使用时</li>
</ul>
<h4 id="什么时候该用引用类型（class）："><a href="#什么时候该用引用类型（class）：" class="headerlink" title="什么时候该用引用类型（class）："></a>什么时候该用引用类型（class）：</h4><ul>
<li>要用==运算符来比较实例身份的时候</li>
<li>你希望有创建一个共享的、可变对象的时候</li>
</ul>
<h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><h4 id="Struct的定义和初始化"><a href="#Struct的定义和初始化" class="headerlink" title="Struct的定义和初始化"></a>Struct的定义和初始化</h4><p><strong>定义结构体</strong><br>下面定义了一个二维空间坐标的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Double</span><br><span class="line">    var y: Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体包含两个名x和y的存储属性。存储属性是被绑定和存储在结构体中的常量或变量。</p>
<p><strong>初始化</strong></p>
<ul>
<li>结构体类型的逐一初始化，所有的结构体都有一个自动生成的成员逐一构造器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var pointA = Point(x: 10, y: 20)</span><br></pre></td></tr></table></figure>

<ul>
<li>默认初始化，我们也可以在定义的时候直接给属性初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    var y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">var pointB = Point()</span><br></pre></td></tr></table></figure>

<p>使用这种方法，<strong>必须给每一个属性指定默认值</strong>。因为Swift中要求<code>init</code>方法必须初始化自定义类型每个属性。如果无法做到，我们可以自定义逐一初始化方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x : Double</span><br><span class="line">    var y : Double</span><br><span class="line">    init(_ x : Double = 0.0, y : Double = 0.0) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们自定义<code>init</code>方法之后，Swift将不会再自动创建逐一初始化方法。</p>
<h4 id="Struct-值类型本质"><a href="#Struct-值类型本质" class="headerlink" title="Struct 值类型本质"></a>Struct 值类型本质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var pointB = Point(200, y: 100)</span><br><span class="line">var pointC = Point(100, y: 200) &#123;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;\(pointC)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pointC = pointB</span><br><span class="line">// Point(x: 200.0, y: 100.0)</span><br><span class="line">pointC.x = 200</span><br><span class="line">//Point(x: 200.0, y: 100.0)</span><br></pre></td></tr></table></figure>
<p>通过<code>didSet</code>观察<code>pointC</code>的变化。当修改<code>pointC</code>变量值时，控制台输出<code>Point(x: 200.0, y: 100.0)</code>, 但是，修改<code>pointC</code>的修改某个属性，也会触发<code>didSet</code>。</p>
<p>这就是值语义的本质：即使字面上修改了<code>pointC</code>变量的某个属性，但实际执行的逻辑是重新给<code>pointC</code>赋值一个新的<code>Point</code>对象。</p>
<h4 id="为Struct添加方法"><a href="#为Struct添加方法" class="headerlink" title="为Struct添加方法"></a>为Struct添加方法</h4><p>给<code>struct</code>添加的方法，默认的都是只读的。计算Point之间的距离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Point &#123;</span><br><span class="line">    func distance(to: Point) -&gt; Double &#123;</span><br><span class="line">        let distX = self.x - to.x</span><br><span class="line">        let distY = self.y - to.y</span><br><span class="line">        return sqrt(distX * distX + distY * distY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pointC.distance(to: Point(0, y: 0))</span><br></pre></td></tr></table></figure>

<p>当我们定义一个移动X轴坐标点的方法时，会导致编译错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Point &#123;</span><br><span class="line">    func move(to: Point) &#123;</span><br><span class="line">        self = to </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里提示self is immutable , 必须使用<code>mutating</code>修饰这个方法， Swift编译器就会在所有的<code>mutating</code>方法第一个参数的位置，自动添加一个<code>inout Self</code>参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Point &#123;</span><br><span class="line">    /* self: inout Self */</span><br><span class="line">    mutating func move(to: Point) &#123;</span><br><span class="line">        self = to</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，是关于Struct类型的基本内容。</p>
<ul>
<li>init方法的合成规则</li>
<li>值语义在struct上的表现</li>
</ul>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>在Swift中，对<code>enum</code>做了诸多改进和增强，它可以有自己的属性，方法，还可以遵从<code>protocol</code>。</p>
<h4 id="定义enum"><a href="#定义enum" class="headerlink" title="定义enum"></a>定义enum</h4><p>定义了一个<code>colorName</code>枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum ColorName &#123;</span><br><span class="line">    case black</span><br><span class="line">    case silver</span><br><span class="line">    case gray</span><br><span class="line">    case white</span><br><span class="line">    case red</span><br><span class="line">    //.... and so on ....</span><br><span class="line">&#125;</span><br><span class="line">// 也可以写在同一行上，用逗号隔开：</span><br><span class="line">enum Month &#123;</span><br><span class="line">    case january, februray, march,</span><br><span class="line">    april, may, june, july,</span><br><span class="line">    august, september, october,</span><br><span class="line">    november, december</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let black = ColorName.black</span><br><span class="line">let jan = Month.january</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br>与C和Objective-C不同，Swift的枚举成员在被创建时不会被赋予一个默认的整数值。上面定义的枚举成员是完备的值，这些值的类型就是定义好的枚举ColorName或Month。</p>
</blockquote>
<h4 id="理解Enum的“Value”"><a href="#理解Enum的“Value”" class="headerlink" title="理解Enum的“Value”"></a>理解Enum的“Value”</h4><h5 id="case-本身就是值"><a href="#case-本身就是值" class="headerlink" title="case 本身就是值"></a>case 本身就是值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func myColor(color: ColorName) -&gt; String &#123;</span><br><span class="line">    switch color &#123;</span><br><span class="line">    case .black:</span><br><span class="line">        return &quot;black&quot;</span><br><span class="line">    case .red:</span><br><span class="line">        return &quot;red&quot;</span><br><span class="line">    default :</span><br><span class="line">        return &quot;other&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>color的类型可以通过type inference推导出是ColorName。因此，可以省略enum的名字。</li>
<li>当Switch…case…将color的所有的值都列举出来时，可以省略default。</li>
</ul>
<h5 id="绑定值-raw-values"><a href="#绑定值-raw-values" class="headerlink" title="绑定值(raw values)"></a>绑定值(raw values)</h5><p>在Swift中，<code>enum</code>默认不会为<code>case</code>绑定一个整数值。但是我们可以手动的绑定值，这个“绑定”来的值，叫做raw values。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction : Int &#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在定义Direction，Swift就会依次把<code>case</code>绑定上值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let east = Direction.east.rawValue // 0</span><br></pre></td></tr></table></figure>
<h5 id="关联值（Associated-value"><a href="#关联值（Associated-value" class="headerlink" title="关联值（Associated value)"></a>关联值（Associated value)</h5><p>在Swift中， 我们可以给每一个<code>case</code>绑定不同类型的值，我们管这种值叫做<code>Associated value</code>。</p>
<p>定义了一个表示CSSColor的<code>enum</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum CSSColor &#123;</span><br><span class="line">    case named(ColorName)</span><br><span class="line">    case rgb(UInt8, UInt8, UInt8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var color1 = CSSColor.named(.black)</span><br><span class="line">var color2 = CSSColor.rgb(0xAA, 0xAA, 0xAA)</span><br><span class="line">switch color2 &#123;</span><br><span class="line">case  let  .named(color):</span><br><span class="line">     print(&quot;\(color)&quot;)</span><br><span class="line">case .rgb(let r, let g, let b):</span><br><span class="line">    print(&quot;\(r), \(g), \(b)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>提取”关联值“的内容时，可以把<code>let</code>和<code>var</code>写在<code>case</code>前面或者后面。例如：<code>named</code>和<code>rgb</code>。</p>
</blockquote>
<h4 id="协议和方法（Protocol-and-Method）"><a href="#协议和方法（Protocol-and-Method）" class="headerlink" title="协议和方法（Protocol and Method）"></a>协议和方法（Protocol and Method）</h4><p>在Swift中，<code>enum</code>和其他的命名类型一样，也可以采用<code>protocol</code>。</p>
<p>例如： 给CSSColor添加一个文本表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension CSSColor: CustomStringConvertible &#123;</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .named(let colorname):</span><br><span class="line">            return colorname.rawValue</span><br><span class="line">        case .rgb(let red, let green, let blue):</span><br><span class="line">            return String(format: &quot;#%02X%02X%02X&quot;, red, green, blue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let color3 = CSSColor.named(.red)</span><br><span class="line">let color4 = CSSColor.rgb(0xBB, 0xBB, 0xBB)</span><br><span class="line">print(&quot;color3=\(color3), color4=\(color4)&quot;) </span><br><span class="line">//color3=red, color4=#BBBBBB</span><br></pre></td></tr></table></figure>

<h4 id="什么是Copy-on-write-COW-？"><a href="#什么是Copy-on-write-COW-？" class="headerlink" title="什么是Copy on write (COW) ？"></a>什么是Copy on write (COW) ？</h4><p>COW是一种常见的计算机技术，有助于在复制结构时提高性能。例如：一个数组中有1000个元素，如果你复制数组到另一个变量，Swift将复制全部的元素，即使最终两个数组的内容相同。</p>
<p>这个问题可以使用COW解决：当将两个变量指向同一数组时，他们指向相同的底层数据。两个变量指向相同的数据可能看起来矛盾。解决方法：当修改第二个变量的时候，Swift才会去复制一个副本，第一个不会改变。<br>通过延迟复制操作，直到实际使用到的时候 才去复制，以此确保没有浪费的工作。</p>
<blockquote>
<p>注意：COW是特别添加到Swift数组和字典的功能，自定义的数据类型不会自动实现。</p>
</blockquote>
<h4 id="值类型和引用类型（Value-vs-Reference-Type）"><a href="#值类型和引用类型（Value-vs-Reference-Type）" class="headerlink" title="值类型和引用类型（Value vs. Reference Type）"></a>值类型和引用类型（Value vs. Reference Type）</h4><p>Class和Struct有很多相似的地方，他们都可以用来自定义类型、都可以有属性、都可以有方法。作为Swift中的引用类型，class表达的是一个具有明生命周期的对象，我们关心的是类的生命周期。而值类型，我关注的是值本身。</p>
<h5 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h5><ol>
<li><p>引用类型必须明确指定init方法<br>Swift中class不会自动生成init方法。如果不定义编译器报错。</p>
</li>
<li><p>引用类型关注的是对象本身 Circle (定义为Class)</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = Circle()</span><br><span class="line">a.radius = 80</span><br><span class="line">var b = a</span><br><span class="line">a.radius = 1000</span><br><span class="line">b.radius // 1000</span><br></pre></td></tr></table></figure>

<p> Circle(定义为Struct)</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = Circle()</span><br><span class="line">a.radius = 80</span><br><span class="line">var b = a</span><br><span class="line">a.radius = 1000</span><br><span class="line">b.radius // 80</span><br></pre></td></tr></table></figure>

<p> 使用值类型创建新对象时，将复制；使用引用类型时，新变量引用同一个对象。这是两者的关键区别。</p>
</li>
<li><p>引用类型的默认值是可以修改的<br>我们之前提到过，给struct添加的方法，默认的都是只读的。如果要修改必须用mutating来修饰。class中则不同，我们可以直接给 self赋值。</p>
</li>
</ol>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="理解class类型的各种init方法"><a href="#理解class类型的各种init方法" class="headerlink" title="理解class类型的各种init方法"></a>理解class类型的各种init方法</h4><p>由于<code>class</code>之间可以存在继承关系，因此它的初始化过程要比<code>struct</code>复杂，为了保证一个<code>class</code>中的所有属性都被初始化，Swift中引入一系列特定规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double</span><br><span class="line">    var y : Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这项写是不行了，因为没有定义初始化方法。</p>
<h5 id="指定构造器-Designated-init"><a href="#指定构造器-Designated-init" class="headerlink" title="指定构造器(Designated init)"></a>指定构造器(Designated init)</h5><p>上面的Point2D有一个默认的初始化方法，有两种办法：第一种给每一个属性都添加默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">&#125;</span><br><span class="line">let origin = Point2D()</span><br></pre></td></tr></table></figure>
<p>这种方法只能创建一个固定的<code>class</code>。另外一种，添加一个<code>memberwise init</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">    init(x: Double, y: Double) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加个一个<code>memberwise init</code>方法，我们可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let point = Point2D(x: 1, y: 1)</span><br></pre></td></tr></table></figure>
<p>但是，如果你现在使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let point = Point2D()  // Error</span><br></pre></td></tr></table></figure>
<p>结果会导致编译错误。 因为，我们接手了<code>init</code>的定义后，编译就不会插手<code>init</code>工作。所以，在定义<code>init</code>方法时添加默认参数， 我们称这种初始化为 <code>designated init</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">    init(x: Double = 0, y: Double = 0) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="便利构造器-（convenience-init）"><a href="#便利构造器-（convenience-init）" class="headerlink" title="便利构造器 （convenience init）"></a>便利构造器 （convenience init）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    var x : Double = 0</span><br><span class="line">    var y : Double = 0</span><br><span class="line">    init(x: Double = 0, y: Double = 0) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init(at: (Double, Double) ) &#123;</span><br><span class="line">        self.init(x: at.0, y: at.1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>convenience</code>关键字修改；</li>
<li>必须调用<code>designated init</code>完成对象的初始化；如果直接调用self.x或self.y，会导致编译错误。</li>
</ul>
<h5 id="可失败构造器-（Failable-init）"><a href="#可失败构造器-（Failable-init）" class="headerlink" title="可失败构造器 （Failable init）"></a>可失败构造器 （Failable init）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point2D &#123;</span><br><span class="line">    // .... </span><br><span class="line">    convenience init?(at: (String, String)) &#123;</span><br><span class="line">        guard let x = Double(at.0),   let y = Double(at.1) else &#123;</span><br><span class="line">          return nil</span><br><span class="line">        &#125;</span><br><span class="line">        self.init(at:(x, y))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>String tuple</code>版的<code>init</code>可能失败，所以需要用<code>init?</code>形式定义。在实现里面，如果<code>String</code>无法转换为成<code>Double</code>， 则返回<code>nil</code>。</p>
<blockquote>
<p>注意：<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此，return nil表示构造失败，而不能return表示成功。</p>
</blockquote>
<h4 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h4><p>当类之间存在继承关系的时候，为了保证派生类和基类的属性都被初始化，Swift采用以下三条规则限制构造器之间的代理调用：</p>
<ul>
<li>指定构造器必须调用其直接父类的指定构造器</li>
<li>便利构造器必须调用同类中定义的其它构造器</li>
<li>便利构造器必须最终导致一个指定构造器被调用</li>
</ul>
<p>简单说：</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>
<h5 id="init的继承"><a href="#init的继承" class="headerlink" title="init的继承"></a>init的继承</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point3D: Point2D &#123;</span><br><span class="line">    var z: Double = 0</span><br><span class="line">&#125;</span><br><span class="line">let origin3D = Point3D()</span><br><span class="line">let point31 = Point3D(x: 1, y: 1)</span><br><span class="line">let point33 = Point3D(at: (2, 3)) // 继承基类 convenience init</span><br></pre></td></tr></table></figure>
<ul>
<li>如果派生类没有定义任何designated initializer，那么它将自动继承所有基类的designated initializer。</li>
<li>如果一个派生类定义了所有基类的designated init,那么它将自动继承基类所有的convenience init。</li>
</ul>
<h5 id="重载init方法"><a href="#重载init方法" class="headerlink" title="重载init方法"></a>重载init方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point3D: Point2D &#123;</span><br><span class="line">    var z: Double</span><br><span class="line">    init(x: Double = 0, y: Double = 0, z: Double = 0) &#123;</span><br><span class="line">        self.z = z</span><br><span class="line">        super.init(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在派生类自定义<code>designated init</code>, 表示明确控制派生类的初始化构造过程, Swift 就不会干涉构造过程。那么，之前创建<code>Point3D</code>就会出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let point33 = Point3D(at: (2, 3))  // Error </span><br></pre></td></tr></table></figure>
<p>如果想让<code>Point3D</code>从<code>Point2D</code>继承所有的<code>convenience init</code>，只有在派生类中实现所有的<code>designated init</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Point3D: Point2D &#123;</span><br><span class="line">    var z: Double</span><br><span class="line">    init(x: Double = 0, y: Double = 0, z: Double = 0) &#123;</span><br><span class="line">        self.z = z</span><br><span class="line">        super.init(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">    override init(x: Double, y: Double) &#123;</span><br><span class="line">        // 注意先后顺序</span><br><span class="line">        self.z = 0</span><br><span class="line">        super.init(x: x, y: y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，就可以正常工作了。只要派生类拥有基类所有的<code>designated init</code>方法，他就会自动获得所有基类的<code>convenience init</code>方法。另外，重载基类<code>convenience init</code>方法，是不需要<code>override</code>关键字修饰的。</p>
<h5 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h5><p>Swift为了保证在一个继承关系中，派生类和基类的属性都可以正确初始化而约定的初始化机制。简单来说，这个机制把派生类的初始化过程分成了两个阶段。</p>
<ul>
<li>阶段一： 从派生类到基类，自下而上让类的每个属性有初始值</li>
<li>阶段二：所有属性都有初始值之后，从基类到派生类，自上而下对类的每个属性进行进一步加工。</li>
</ul>
<p>两段式构造过程让构造过程更安全，同时整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外赋予不同的值。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://developer.apple.com/reference/swift">Swift Standard Library</a><br><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift">Getting to Know Enums, Structs and Classes in Swift - raywenderlich</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a10f554ac63b">摘自</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Swift/" rel="tag"># Swift</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/03/26/Flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95/" rel="prev" title="Flex布局语法">
      <i class="fa fa-chevron-left"></i> Flex布局语法
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/04/02/Swift%E5%8F%AF%E9%80%89%E5%80%BC/" rel="next" title="Swift可选值">
      Swift可选值 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Struct-Class-and-Enum-%E5%AF%B9%E6%AF%94"><span class="nav-number">2.</span> <span class="nav-text">Struct Class and Enum 对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">枚举、结构体、类的共同点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%89%B9%E6%9C%89%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">类特有的功能：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8A%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">如何抉择？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">什么时候该用值类型：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88class%EF%BC%89%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">什么时候该用引用类型（class）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Struct"><span class="nav-number">4.</span> <span class="nav-text">Struct</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">Struct的定义和初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Struct-%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%9C%AC%E8%B4%A8"><span class="nav-number">4.2.</span> <span class="nav-text">Struct 值类型本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BAStruct%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">为Struct添加方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enum"><span class="nav-number">5.</span> <span class="nav-text">Enum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89enum"><span class="nav-number">5.1.</span> <span class="nav-text">定义enum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3Enum%E7%9A%84%E2%80%9CValue%E2%80%9D"><span class="nav-number">5.2.</span> <span class="nav-text">理解Enum的“Value”</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#case-%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E5%80%BC"><span class="nav-number">5.2.1.</span> <span class="nav-text">case 本身就是值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%80%BC-raw-values"><span class="nav-number">5.2.2.</span> <span class="nav-text">绑定值(raw values)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%80%BC%EF%BC%88Associated-value"><span class="nav-number">5.2.3.</span> <span class="nav-text">关联值（Associated value)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%88Protocol-and-Method%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">协议和方法（Protocol and Method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCopy-on-write-COW-%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">什么是Copy on write (COW) ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88Value-vs-Reference-Type%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">值类型和引用类型（Value vs. Reference Type）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94"><span class="nav-number">5.5.1.</span> <span class="nav-text">差异对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">6.</span> <span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3class%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%84%E7%A7%8Dinit%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">理解class类型的各种init方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%9E%84%E9%80%A0%E5%99%A8-Designated-init"><span class="nav-number">6.1.1.</span> <span class="nav-text">指定构造器(Designated init)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%BF%E5%88%A9%E6%9E%84%E9%80%A0%E5%99%A8-%EF%BC%88convenience-init%EF%BC%89"><span class="nav-number">6.1.2.</span> <span class="nav-text">便利构造器 （convenience init）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8-%EF%BC%88Failable-init%EF%BC%89"><span class="nav-number">6.1.3.</span> <span class="nav-text">可失败构造器 （Failable init）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">类的继承和构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#init%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">6.2.1.</span> <span class="nav-text">init的继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDinit%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">重载init方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.3.</span> <span class="nav-text">两段式构造过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Marks - 上海</p>
  <div class="site-description" itemprop="description">小码农的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Marks - 上海</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
